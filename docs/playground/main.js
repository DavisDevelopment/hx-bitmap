// Generated by Haxe 4.0.0-rc.3+68333d85d
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Main = function() { };
Main.__name__ = true;
Main.loaded = function(data) {
	var bytes = haxe_io_Bytes.ofData(data);
	var input = new haxe_io_BytesInput(bytes);
	var bitmap1 = new bitmap_PNGBitmap();
	bitmap1.load(input);
	new app_App(bitmap1,new app_State());
};
Main.main = function() {
	applicationFetchImage("bluebells.png",Main.loaded);
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var app_App = function(b,s) {
	this.bitmap = b;
	this.state = s;
	this.start();
};
app_App.__name__ = true;
app_App.prototype = {
	start: function() {
		var _gthis = this;
		window.document.querySelector(".shapes").addEventListener("click",function() {
			_gthis.exampleSelected("shapes");
			return;
		});
		window.document.querySelector(".convolutions").addEventListener("click",function() {
			_gthis.exampleSelected("convolutions");
			return;
		});
		window.document.querySelector(".affine").addEventListener("click",function() {
			_gthis.exampleSelected("affine");
			return;
		});
		window.document.querySelector(".pixelize").addEventListener("click",function() {
			_gthis.exampleSelected("pixelize");
			return;
		});
		window.document.querySelector(".colors").addEventListener("click",function() {
			_gthis.exampleSelected("colors");
			return;
		});
		window.document.querySelector(".getSource").addEventListener("click",function() {
			_gthis.getSource();
		});
		this.input = window.document.querySelector(".input");
		this.outputs = [window.document.querySelector(".output1"),window.document.querySelector(".output2"),window.document.querySelector(".output3"),window.document.querySelector(".output4"),window.document.querySelector(".output5")];
		this.input.src = this.bitmap.io.toDataUrl();
		this.outputs.forEach(function(o,i) {
			return o.addEventListener("click",function(e) {
				return applicationDownload(e.currentTarget.src,"output-" + i + ".png");
			});
		});
	}
	,getSource: function() {
		window.alert(Std.string(this.state.example.getSource()));
	}
	,exampleSelected: function(name) {
		var ex;
		if(name == "convolutions") {
			ex = new examples_Convolutions();
		} else if(name == "shapes") {
			ex = new examples_Shapes();
		} else if(name == "pixelize") {
			ex = new examples_Pixelize();
		} else if(name == "colors") {
			ex = new examples_Colors();
		} else if(name == "affine") {
			ex = new examples_AffineTransformation();
		} else {
			throw new js__$Boot_HaxeError("example not recognized");
		}
		if(ex != null) {
			this.state.example = ex;
			ex.run(this.bitmap,this.outputs);
		}
	}
};
var app_State = function() {
	this.example = new examples_Shapes();
};
app_State.__name__ = true;
var bitmap_AbstractBitmap = function(w,h,f) {
	if(f == null) {
		f = bitmap_PixelFormat.RGBA;
	}
	if(h == null) {
		h = 1;
	}
	if(w == null) {
		w = 1;
	}
	this.bg = -1;
	this.int32Mode = false;
	this.noRangeCheck = true;
	this.draw = new bitmap_Draw(this);
	this.transform = new bitmap_transformation_Transform(this);
	this.color = new bitmap_transformation_Colors(this);
	this.io = new bitmap_BitmapIO(this);
	if(w > 0 && h > 0) {
		this.width = w;
		this.height = h;
		this.data = new haxe_io_Bytes(new ArrayBuffer(w * h * 4));
		this.format = f;
		this.fill();
	}
};
bitmap_AbstractBitmap.__name__ = true;
bitmap_AbstractBitmap.prototype = {
	fill: function(bg_) {
		bg_ = bg_ == null ? this.bg : bg_;
		var _g = 0;
		var _g1 = this.width;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g11 = this.height;
			while(_g2 < _g11) {
				var y = _g2++;
				this.set(x,y,bg_);
			}
		}
	}
	,get: function(x,y,noError) {
		var i = (y * this.width + x) * 4;
		if(i < 0 || i > this.data.length - 4) {
			if(!this.noRangeCheck && !noError) {
				var actual = "get outOfBounds";
				var expected = null;
				if(actual != expected) {
					throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
				}
			} else {
				return this.bg;
			}
		}
		if(this.int32Mode) {
			var c = this.data.getInt32(i);
			return (c >> 24 & 255) + ((c >> 16 & 255) << 8) + ((c >> 8 & 255) << 16) + ((c & 255) << 24);
		} else {
			var red = this.data.b.bufferValue.bytes[i];
			var green = this.data.b.bufferValue.bytes[i + 1];
			var blue = this.data.b.bufferValue.bytes[i + 2];
			var alpha = this.data.b.bufferValue.bytes[i + 3];
			return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
		}
	}
	,byteIndex: function(x,y) {
		return (y * this.width + x) * 4;
	}
	,copy: function(r) {
		throw new js__$Boot_HaxeError("Abstract method call");
	}
	,set: function(x,y,c,noError) {
		var i = (y * this.width + x) * 4;
		if(i < 0 || i > this.data.length - 4) {
			if(!this.noRangeCheck && noError != true) {
				var actual = "set outOfBounds";
				var expected = null;
				if(actual != expected) {
					throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
				}
			} else {
				return true;
			}
		}
		if(this.int32Mode) {
			this.data.setInt32(i,(c >> 24 & 255) + (c >> 8 & 65280) + ((c & 65280) << 8) + ((c & 255) << 24));
		} else {
			this.data.b[i] = c >> 24 & 255;
			this.data.b[i + 1] = c >> 16 & 255;
			this.data.b[i + 2] = c >> 8 & 255;
			this.data.b[i + 3] = c & 255;
		}
		return false;
	}
	,load: function(input,f) {
		throw new js__$Boot_HaxeError("Abstract method call");
	}
	,save: function(output) {
		throw new js__$Boot_HaxeError("Abstract method call");
	}
	,clone: function(fill_) {
		if(fill_ == null) {
			fill_ = false;
		}
		var bitmap1 = new bitmap_PNGBitmap();
		bitmap1.width = this.width;
		bitmap1.height = this.height;
		bitmap1.format = this.format;
		bitmap1.noRangeCheck = this.noRangeCheck;
		if(!fill_) {
			bitmap1.data = this.data.sub(0,this.data.length);
		} else {
			bitmap1.data = new haxe_io_Bytes(new ArrayBuffer(this.data.length));
			bitmap1.fill();
		}
		return bitmap1;
	}
	,equals: function(b,region) {
		return bitmap_BitmapUtil.bitmapEquals(this,b,region);
	}
	,copyFrom: function(b,bCoords,regionThis) {
		var _g = 0;
		var _g1 = regionThis.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g11 = regionThis.width;
			while(_g2 < _g11) {
				var x = _g2++;
				this.set(regionThis.x + x,regionThis.y + y,b.get(bCoords.x + x,bCoords.y + y));
			}
		}
	}
	,compare: function(b,regionB,thisRegion) {
		return bitmap_BitmapUtil.compare(this,b,regionB,thisRegion);
	}
	,bounds: function() {
		return { x : 0, y : 0, width : this.width, height : this.height};
	}
	,setInt32: function(i,c) {
		this.data.setInt32(i,(c >> 24 & 255) + (c >> 8 & 65280) + ((c & 65280) << 8) + ((c & 255) << 24));
	}
	,setInt8: function(i,c) {
		this.data.b[i] = c >> 24 & 255;
		this.data.b[i + 1] = c >> 16 & 255;
		this.data.b[i + 2] = c >> 8 & 255;
		this.data.b[i + 3] = c & 255;
	}
	,getInt32: function(i) {
		var c = this.data.getInt32(i);
		return (c >> 24 & 255) + ((c >> 16 & 255) << 8) + ((c >> 8 & 255) << 16) + ((c & 255) << 24);
	}
	,getInt8: function(i) {
		var red = this.data.b.bufferValue.bytes[i];
		var green = this.data.b.bufferValue.bytes[i + 1];
		var blue = this.data.b.bufferValue.bytes[i + 2];
		var alpha = this.data.b.bufferValue.bytes[i + 3];
		return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
	}
};
var bitmap_BitmapIO = function(b) {
	this.bitmap = b;
};
bitmap_BitmapIO.__name__ = true;
bitmap_BitmapIO.prototype = {
	toDataUrl: function(mime,name) {
		if(mime == null) {
			mime = "image/png";
		}
		return bitmap_BitmapUtil.toDataUrl(this.bitmap,mime,name);
	}
	,toBase64: function() {
		return bitmap_BitmapUtil.toBase64(this.bitmap);
	}
	,fromBase64: function(base64) {
		return bitmap_BitmapUtil.fromBase64(base64,this.bitmap);
	}
	,fromDataUrl: function(dataurl) {
		return bitmap_BitmapUtil.fromDataUrl(dataurl,this.bitmap);
	}
};
var bitmap_BitmapUtil = function() { };
bitmap_BitmapUtil.__name__ = true;
bitmap_BitmapUtil.bitmapEquals = function(a,b,region) {
	if(a.width != b.width || a.height != b.height) {
		return false;
	}
	if(region == null) {
		var first = a.width;
		var second = b.width;
		var first1 = a.height;
		var second1 = b.height;
		region = { x : 0, y : 0, width : first < second ? first : second, height : first1 < second1 ? first1 : second1};
	}
	return a.data.compare(b.data) == 0;
};
bitmap_BitmapUtil.compare = function(a,b,regionA,regionB) {
	if(regionA == null && regionB == null && (a.width != b.width || b.height != a.height)) {
		throw new js__$Boot_HaxeError("No regions given and bitmaps with different sizes");
	}
	regionA = regionA == null ? regionB == null ? a.bounds() : regionB : regionA;
	regionB = regionB == null ? regionA == null ? b.bounds() : regionA : regionB;
	if(regionA.width != regionB.width || regionA.height != regionB.height) {
		throw new js__$Boot_HaxeError("Regions given or inferred have different sizes");
	}
	var va = 0;
	var vb = 0;
	var startA = a.byteIndex(regionA.x,regionA.y);
	var endA = a.byteIndex(regionA.x + regionA.width,regionA.y + regionA.height);
	var startB = a.byteIndex(regionB.x,regionB.y);
	var endB = a.byteIndex(regionB.x + regionB.width,regionB.y + regionB.height);
	var actual = endA - startA;
	var expected = endB - startB;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	if(!(endA > startA && endB > startB)) {
		throw new js__$Boot_HaxeError("FAIL: endA > startA && endB > startB");
	}
	if(!(startA >= 0 && startB >= 0)) {
		throw new js__$Boot_HaxeError("FAIL: startA >= 0 && startB >= 0");
	}
	var _g = 0;
	var _g1 = endA - startA;
	while(_g < _g1) {
		var i = _g++;
		var v = a.data.b[startA + i];
		va += isNaN(v) ? 0 : v;
		v = b.data.b[startB + i];
		vb += isNaN(v) ? 0 : v;
	}
	return bitmap_Util.dist(va,vb) / ((endA - startA) * 255) * (va > vb ? -1 : 1);
};
bitmap_BitmapUtil.blend = function(b1,b2,b3,blend) {
	var first = b1.width;
	var second = b2.width;
	var w = first < second ? first : second;
	var first1 = b1.height;
	var second1 = b2.height;
	var h = first1 < second1 ? first1 : second1;
	var _g = 0;
	var _g1 = h;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = 0;
		var _g11 = w;
		while(_g2 < _g11) {
			var x = _g2++;
			var c1 = b1.get(x,y);
			var c2 = b2.get(x,y);
			var blend1 = blend;
			blend1 = blend1 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend1;
			blend1.factor = blend1.factor == null ? 0.5 : blend1.factor;
			var tmp;
			if(blend1.type == bitmap_Blend.alpha) {
				tmp = c2;
			} else if(blend1.type == bitmap_Blend.mean) {
				var red = (c1 >> 24 & 255) * blend1.factor + (c2 >> 24 & 255) * (1 - blend1.factor) | 0;
				var green = (c1 >> 16 & 255) * blend1.factor + (c2 >> 16 & 255) * (1 - blend1.factor) | 0;
				var blue = (c1 >> 8 & 255) * blend1.factor + (c2 >> 8 & 255) * (1 - blend1.factor) | 0;
				var alpha = (c1 & 255) * blend1.factor + (c2 & 255) * (1 - blend1.factor) | 0;
				tmp = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
			} else {
				tmp = c2;
			}
			b3.set(x,y,tmp);
		}
	}
	return b3;
};
bitmap_BitmapUtil.toDataUrl = function(bitmap1,mime,name) {
	if(mime == null) {
		mime = "image/png";
	}
	var b64 = bitmap_BitmapUtil.toBase64(bitmap1);
	return "data:" + mime + ";" + (name == null ? "" : name + ";") + "base64," + b64;
};
bitmap_BitmapUtil.toBase64 = function(bitmap1) {
	var ii = new haxe_io_BytesOutput();
	bitmap1.save(ii);
	var bytes = ii.getBytes();
	return haxe_crypto_Base64.encode(bytes);
};
bitmap_BitmapUtil.fromBase64 = function(base64,bitmap1) {
	bitmap1 = bitmap1 == null ? new bitmap_PNGBitmap() : bitmap1;
	var bytes = haxe_crypto_Base64.decode(base64);
	var ii = new haxe_io_BytesInput(bytes);
	bitmap1.load(ii);
	return bitmap1;
};
bitmap_BitmapUtil.fromDataUrl = function(dataurl,bitmap1) {
	var base64 = bitmap_Util.urlToBase64(dataurl);
	return bitmap_BitmapUtil.fromBase64(base64,bitmap1);
};
var bitmap__$Color_Color_$Impl_$ = {};
bitmap__$Color_Color_$Impl_$.__name__ = true;
bitmap__$Color_Color_$Impl_$._new = function(rgba) {
	var this1 = rgba;
	return this1;
};
bitmap__$Color_Color_$Impl_$.create = function(red,green,blue,alpha) {
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
bitmap__$Color_Color_$Impl_$.fromInt = function(rgba) {
	return rgba;
};
bitmap__$Color_Color_$Impl_$.get_r = function(this1) {
	return this1 >> 24 & 255;
};
bitmap__$Color_Color_$Impl_$.get_g = function(this1) {
	return this1 >> 16 & 255;
};
bitmap__$Color_Color_$Impl_$.get_b = function(this1) {
	return this1 >> 8 & 255;
};
bitmap__$Color_Color_$Impl_$.get_a = function(this1) {
	return this1 & 255;
};
var bitmap_ColorUtil = function() { };
bitmap_ColorUtil.__name__ = true;
bitmap_ColorUtil.colorEquals = function(a,b) {
	if((a >> 24 & 255) == (b >> 24 & 255) && (a >> 16 & 255) == (b >> 16 & 255) && (a >> 8 & 255) == (b >> 8 & 255)) {
		return (a & 255) == (b & 255);
	} else {
		return false;
	}
};
bitmap_ColorUtil.average = function(image,region,alpha) {
	if(!(image != null)) {
		throw new js__$Boot_HaxeError("FAIL: image != null");
	}
	var totalRed = 0;
	var totalGreen = 0;
	var totalBlue = 0;
	var totalAlpha = 0;
	if(region == null) {
		region = { x : 0, y : 0, width : image.width, height : image.height};
	}
	var _g = region.x;
	var _g1 = region.x + region.width;
	while(_g < _g1) {
		var x = _g++;
		var _g2 = region.y;
		var _g11 = region.y + region.height;
		while(_g2 < _g11) {
			var y = _g2++;
			var pixel = image.get(x,y);
			totalRed += pixel >> 24 & 255;
			totalGreen += pixel >> 16 & 255;
			totalBlue += pixel >> 8 & 255;
			totalAlpha += pixel & 255;
		}
	}
	var size = region.width * region.height;
	var red = Math.round(totalRed / size) | 0;
	var green = Math.round(totalGreen / size) | 0;
	var blue = Math.round(totalBlue / size) | 0;
	var alpha1 = alpha == null ? Math.round(totalAlpha / size) | 0 : alpha;
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha1 < 0 ? 0 : alpha1 > 255 ? 255 : alpha1);
};
bitmap_ColorUtil.random = function(alpha) {
	var red = Math.round(255 * Math.random());
	var green = Math.round(255 * Math.random());
	var blue = Math.round(255 * Math.random());
	var alpha1 = alpha == null ? Math.round(255 * Math.random()) : alpha;
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha1 < 0 ? 0 : alpha1 > 255 ? 255 : alpha1);
};
bitmap_ColorUtil.randomGray = function(alpha) {
	var g = Math.round(255 * Math.random());
	var alpha1 = alpha == null ? Math.round(255 * Math.random()) : alpha;
	return ((g < 0 ? 0 : g > 255 ? 255 : g) << 24) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 16) + ((g < 0 ? 0 : g > 255 ? 255 : g) << 8) + (alpha1 < 0 ? 0 : alpha1 > 255 ? 255 : alpha1);
};
bitmap_ColorUtil.blendColors = function(c1,c2,blend) {
	blend = blend == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend;
	blend.factor = blend.factor == null ? 0.5 : blend.factor;
	if(blend.type == bitmap_Blend.alpha) {
		return c2;
	} else if(blend.type == bitmap_Blend.mean) {
		var red = (c1 >> 24 & 255) * blend.factor + (c2 >> 24 & 255) * (1 - blend.factor) | 0;
		var green = (c1 >> 16 & 255) * blend.factor + (c2 >> 16 & 255) * (1 - blend.factor) | 0;
		var blue = (c1 >> 8 & 255) * blend.factor + (c2 >> 8 & 255) * (1 - blend.factor) | 0;
		var alpha = (c1 & 255) * blend.factor + (c2 & 255) * (1 - blend.factor) | 0;
		return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
	} else {
		return c2;
	}
};
bitmap_ColorUtil.filter = function(c,o) {
	o.red = o.red == null ? { a : 1.0, c : 0.0} : o.red;
	o.green = o.green == null ? { a : 1.0, c : 0.0} : o.green;
	o.blue = o.blue == null ? { a : 1.0, c : 0.0} : o.blue;
	o.alpha = o.alpha == null ? { a : 1.0, c : 0.0} : o.alpha;
	var red = Math.round((c >> 24 & 255) * o.red.a + o.red.c);
	var green = Math.round((c >> 16 & 255) * o.green.a + o.green.c);
	var blue = Math.round((c >> 8 & 255) * o.blue.a + o.blue.c);
	var alpha = Math.round((c & 255) * o.alpha.a + o.alpha.c);
	return ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
};
var bitmap_Draw = function(b) {
	this.bitmap = b;
};
bitmap_Draw.__name__ = true;
bitmap_Draw.prototype = {
	line: function(x1,y1,x2,y2,c,blend,returnPoints) {
		if(returnPoints == null) {
			returnPoints = false;
		}
		var dx = x2 - x1;
		var dy = y2 - y1;
		var dxabs = dx < 0 ? -dx : dx;
		var dyabs = dy < 0 ? -dy : dy;
		var sdx = dx < 0 ? -1 : dx > 0 ? 1 : 0;
		var sdy = dy < 0 ? -1 : dy > 0 ? 1 : 0;
		var x = dyabs >> 1;
		var y = dxabs >> 1;
		var px = x1;
		var py = y1;
		var points = [];
		if(dxabs >= dyabs) {
			var _g = 0;
			var _g1 = dxabs;
			while(_g < _g1) {
				var i = _g++;
				y += dyabs;
				if(y >= dxabs) {
					y -= dxabs;
					py += sdy;
				}
				px += sdx;
				var tmp = this.bitmap;
				var tmp1;
				if(blend == null || blend.type == bitmap_Blend.none) {
					tmp1 = c;
				} else {
					var c1 = this.bitmap.get(px,py);
					var blend1 = blend;
					blend1 = blend1 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend1;
					blend1.factor = blend1.factor == null ? 0.5 : blend1.factor;
					if(blend1.type == bitmap_Blend.alpha) {
						tmp1 = c;
					} else if(blend1.type == bitmap_Blend.mean) {
						var red = (c1 >> 24 & 255) * blend1.factor + (c >> 24 & 255) * (1 - blend1.factor) | 0;
						var green = (c1 >> 16 & 255) * blend1.factor + (c >> 16 & 255) * (1 - blend1.factor) | 0;
						var blue = (c1 >> 8 & 255) * blend1.factor + (c >> 8 & 255) * (1 - blend1.factor) | 0;
						var alpha = (c1 & 255) * blend1.factor + (c & 255) * (1 - blend1.factor) | 0;
						tmp1 = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
					} else {
						tmp1 = c;
					}
				}
				tmp.set(px,py,tmp1);
				points.push({ x : px, y : py});
			}
		} else {
			var _g2 = 0;
			var _g11 = dyabs;
			while(_g2 < _g11) {
				var i1 = _g2++;
				x += dxabs;
				if(x >= dyabs) {
					x -= dyabs;
					px += sdx;
				}
				py += sdy;
				var tmp2 = this.bitmap;
				var tmp3;
				if(blend == null || blend.type == bitmap_Blend.none) {
					tmp3 = c;
				} else {
					var c11 = this.bitmap.get(px,py);
					var blend2 = blend;
					blend2 = blend2 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend2;
					blend2.factor = blend2.factor == null ? 0.5 : blend2.factor;
					if(blend2.type == bitmap_Blend.alpha) {
						tmp3 = c;
					} else if(blend2.type == bitmap_Blend.mean) {
						var red1 = (c11 >> 24 & 255) * blend2.factor + (c >> 24 & 255) * (1 - blend2.factor) | 0;
						var green1 = (c11 >> 16 & 255) * blend2.factor + (c >> 16 & 255) * (1 - blend2.factor) | 0;
						var blue1 = (c11 >> 8 & 255) * blend2.factor + (c >> 8 & 255) * (1 - blend2.factor) | 0;
						var alpha1 = (c11 & 255) * blend2.factor + (c & 255) * (1 - blend2.factor) | 0;
						tmp3 = ((red1 < 0 ? 0 : red1 > 255 ? 255 : red1) << 24) + ((green1 < 0 ? 0 : green1 > 255 ? 255 : green1) << 16) + ((blue1 < 0 ? 0 : blue1 > 255 ? 255 : blue1) << 8) + (alpha1 < 0 ? 0 : alpha1 > 255 ? 255 : alpha1);
					} else {
						tmp3 = c;
					}
				}
				tmp2.set(px,py,tmp3);
				points.push({ x : px, y : py});
			}
		}
		return points;
	}
	,rectangle: function(r) {
		if(r.fill) {
			var _g = 0;
			var _g1 = r.height;
			while(_g < _g1) {
				var y2 = _g++;
				var _g2 = 0;
				var _g11 = r.width;
				while(_g2 < _g11) {
					var x2 = _g2++;
					var x = x2 + r.x;
					var y = y2 + r.y;
					var c = r.c;
					var blend = r.blend;
					var tmp = this.bitmap;
					var tmp1;
					if(blend == null || blend.type == bitmap_Blend.none) {
						tmp1 = c;
					} else {
						var c1 = this.bitmap.get(x,y);
						var blend1 = blend;
						blend1 = blend1 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend1;
						blend1.factor = blend1.factor == null ? 0.5 : blend1.factor;
						if(blend1.type == bitmap_Blend.alpha) {
							tmp1 = c;
						} else if(blend1.type == bitmap_Blend.mean) {
							var red = (c1 >> 24 & 255) * blend1.factor + (c >> 24 & 255) * (1 - blend1.factor) | 0;
							var green = (c1 >> 16 & 255) * blend1.factor + (c >> 16 & 255) * (1 - blend1.factor) | 0;
							var blue = (c1 >> 8 & 255) * blend1.factor + (c >> 8 & 255) * (1 - blend1.factor) | 0;
							var alpha = (c1 & 255) * blend1.factor + (c & 255) * (1 - blend1.factor) | 0;
							tmp1 = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
						} else {
							tmp1 = c;
						}
					}
					tmp.set(x,y,tmp1);
				}
			}
		} else {
			this.line(r.x,r.y,r.x + r.width,r.y,r.c,r.blend);
			this.line(r.x + r.width,r.y,r.x + r.width,r.y + r.height,r.c,r.blend);
			this.line(r.x + r.width,r.y + r.height,r.x,r.y + r.height,r.c,r.blend);
			this.line(r.x,r.y + r.height,r.x,r.y,r.c,r.blend);
		}
	}
	,rectangle2: function(x,y,width,height,c,fill,blend) {
		this.rectangle({ x : x, y : y, width : width, height : height, c : c, fill : fill, blend : blend});
	}
	,triangle: function(x1,y1,x2,y2,x3,y3,c,fill,blend) {
		if(fill == null) {
			fill = false;
		}
		var points = this.line(x1,y1,x2,y2,c,blend,fill);
		points = points.concat(this.line(x2,y2,x3,y3,c,blend,fill));
		points = points.concat(this.line(x3,y3,x1,y1,c,blend,fill));
		if(!fill) {
			return;
		}
		var second = y2 > y3 ? y2 : y3;
		var maxY = y1 > second ? y1 : second;
		var second1 = y2 < y3 ? y2 : y3;
		var minY = y1 < second1 ? y1 : second1;
		var _g = minY;
		var _g1 = maxY + 1;
		while(_g < _g1) {
			var y = [_g++];
			var found = points.filter((function(y4) {
				return function(p) {
					return Math.round(p.y) == y4[0];
				};
			})(y));
			if(found.length > 1) {
				if(found.length > 2) {
					var a = found.map((function() {
						return function(p1) {
							return p1.x;
						};
					})());
					var e;
					if(a == null || a.length == 0) {
						e = { min : 0, max : 0};
					} else {
						var min = a[0];
						var max = a[0];
						var _g2 = 0;
						while(_g2 < a.length) {
							var value = a[_g2];
							++_g2;
							if(min > value) {
								min = value;
							}
							if(max < value) {
								max = value;
							}
						}
						e = { min : min, max : max};
					}
					this.line(e.min,y[0],e.max,y[0],c,blend);
				} else {
					this.line(found[0].x,y[0],found[1].x,y[0],c,blend);
				}
			} else if(found.length == 1) {
				var x = found[0].x;
				var y5 = found[0].y;
				var tmp = this.bitmap;
				var tmp1;
				if(blend == null || blend.type == bitmap_Blend.none) {
					tmp1 = c;
				} else {
					var c1 = this.bitmap.get(x,y5);
					var blend1 = blend;
					blend1 = blend1 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend1;
					blend1.factor = blend1.factor == null ? 0.5 : blend1.factor;
					if(blend1.type == bitmap_Blend.alpha) {
						tmp1 = c;
					} else if(blend1.type == bitmap_Blend.mean) {
						var red = (c1 >> 24 & 255) * blend1.factor + (c >> 24 & 255) * (1 - blend1.factor) | 0;
						var green = (c1 >> 16 & 255) * blend1.factor + (c >> 16 & 255) * (1 - blend1.factor) | 0;
						var blue = (c1 >> 8 & 255) * blend1.factor + (c >> 8 & 255) * (1 - blend1.factor) | 0;
						var alpha = (c1 & 255) * blend1.factor + (c & 255) * (1 - blend1.factor) | 0;
						tmp1 = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
					} else {
						tmp1 = c;
					}
				}
				tmp.set(x,y5,tmp1);
			} else {
				console.log("bitmap/Draw.hx:122:",found.length);
			}
		}
	}
	,set: function(x,y,c,blend) {
		var tmp = this.bitmap;
		var tmp1;
		if(blend == null || blend.type == bitmap_Blend.none) {
			tmp1 = c;
		} else {
			var c1 = this.bitmap.get(x,y);
			var blend1 = blend;
			blend1 = blend1 == null ? { type : bitmap_Blend.mean, factor : 0.5} : blend1;
			blend1.factor = blend1.factor == null ? 0.5 : blend1.factor;
			if(blend1.type == bitmap_Blend.alpha) {
				tmp1 = c;
			} else if(blend1.type == bitmap_Blend.mean) {
				var red = (c1 >> 24 & 255) * blend1.factor + (c >> 24 & 255) * (1 - blend1.factor) | 0;
				var green = (c1 >> 16 & 255) * blend1.factor + (c >> 16 & 255) * (1 - blend1.factor) | 0;
				var blue = (c1 >> 8 & 255) * blend1.factor + (c >> 8 & 255) * (1 - blend1.factor) | 0;
				var alpha = (c1 & 255) * blend1.factor + (c & 255) * (1 - blend1.factor) | 0;
				tmp1 = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
			} else {
				tmp1 = c;
			}
		}
		tmp.set(x,y,tmp1);
	}
};
var bitmap_PNGBitmap = function(w,h,f) {
	bitmap_AbstractBitmap.call(this,w,h,f);
};
bitmap_PNGBitmap.__name__ = true;
bitmap_PNGBitmap.create = function(input,format) {
	var bitmap1 = new bitmap_PNGBitmap();
	bitmap1.load(input,format);
	return bitmap1;
};
bitmap_PNGBitmap.__super__ = bitmap_AbstractBitmap;
bitmap_PNGBitmap.prototype = $extend(bitmap_AbstractBitmap.prototype,{
	load: function(input,f) {
		if(f == null) {
			f = bitmap_PixelFormat.RGBA;
		}
		if(f != bitmap_PixelFormat.RGBA && f != bitmap_PixelFormat.ARGB) {
			throw new js__$Boot_HaxeError("Image format not supported");
		}
		var d = new format_png_Reader(input).read();
		var hdr = format_png_Tools.getHeader(d);
		this.width = hdr.width;
		this.height = hdr.height;
		this.format = f;
		this.data = format_png_Tools.extract32(d);
		format_png_Tools.reverseBytes(this.data);
		if(this.format == bitmap_PixelFormat.RGBA) {
			var bytes = this.data;
			if(!(bytes != null)) {
				throw new js__$Boot_HaxeError("FAIL: bytes != null");
			}
			var actual = bytes.length % 4;
			var expected = 0;
			if(actual != expected) {
				throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
			}
			var length = bytes.length;
			var i = 0;
			while(i < length) {
				var a = bytes.b[i];
				var r = bytes.b[i + 1];
				var g = bytes.b[i + 2];
				var b = bytes.b[i + 3];
				bytes.b[i] = r;
				bytes.b[i + 1] = g;
				bytes.b[i + 2] = b;
				bytes.b[i + 3] = a;
				i += 4;
			}
		}
	}
	,save: function(output) {
		bitmap_support_ZipSupport.haxeZipCompressJsSupport();
		var copy = this.data.sub(0,this.data.length);
		if(this.format == null || this.format == bitmap_PixelFormat.RGBA) {
			if(!(copy != null)) {
				throw new js__$Boot_HaxeError("FAIL: bytes != null");
			}
			var actual = copy.length % 4;
			var expected = 0;
			if(actual != expected) {
				throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
			}
			var length = copy.length;
			var i = 0;
			while(i < length) {
				var r = copy.b[i];
				var g = copy.b[i + 1];
				var b = copy.b[i + 2];
				var a = copy.b[i + 3];
				copy.b[i] = a;
				copy.b[i + 1] = r;
				copy.b[i + 2] = g;
				copy.b[i + 3] = b;
				i += 4;
			}
			copy = copy;
		}
		var data = format_png_Tools.build32ARGB(this.width,this.height,copy);
		new format_png_Writer(output).write(data);
	}
	,copy: function(r) {
		if(r == null) {
			r = this.bounds();
		}
		var b = new bitmap_PNGBitmap(r.width,r.height);
		b.noRangeCheck = this.noRangeCheck;
		b.copyFrom(this,{ x : r.x, y : r.y},{ x : 0, y : 0, width : r.width, height : r.height});
		return b;
	}
});
var bitmap_PixelFormatUtil = function() { };
bitmap_PixelFormatUtil.__name__ = true;
bitmap_PixelFormatUtil.argbToRgba = function(bytes) {
	if(!(bytes != null)) {
		throw new js__$Boot_HaxeError("FAIL: bytes != null");
	}
	var actual = bytes.length % 4;
	var expected = 0;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var length = bytes.length;
	var i = 0;
	while(i < length) {
		var a = bytes.b[i];
		var r = bytes.b[i + 1];
		var g = bytes.b[i + 2];
		var b = bytes.b[i + 3];
		bytes.b[i] = r;
		bytes.b[i + 1] = g;
		bytes.b[i + 2] = b;
		bytes.b[i + 3] = a;
		i += 4;
	}
	return bytes;
};
bitmap_PixelFormatUtil.rgbaToArgb = function(bytes) {
	if(!(bytes != null)) {
		throw new js__$Boot_HaxeError("FAIL: bytes != null");
	}
	var actual = bytes.length % 4;
	var expected = 0;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var length = bytes.length;
	var i = 0;
	while(i < length) {
		var r = bytes.b[i];
		var g = bytes.b[i + 1];
		var b = bytes.b[i + 2];
		var a = bytes.b[i + 3];
		bytes.b[i] = a;
		bytes.b[i + 1] = r;
		bytes.b[i + 2] = g;
		bytes.b[i + 3] = b;
		i += 4;
	}
	return bytes;
};
bitmap_PixelFormatUtil.brgaToRgba = function(bytes) {
	if(!(bytes != null)) {
		throw new js__$Boot_HaxeError("FAIL: bytes != null");
	}
	var actual = bytes.length % 4;
	var expected = 0;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var length = bytes.length;
	var i = 0;
	while(i < length) {
		var b = bytes.b[i];
		var r = bytes.b[i + 1];
		var g = bytes.b[i + 2];
		var a = bytes.b[i + 3];
		bytes.b[i] = r;
		bytes.b[i + 1] = g;
		bytes.b[i + 2] = b;
		bytes.b[i + 3] = a;
		i += 4;
	}
	return bytes;
};
bitmap_PixelFormatUtil.rgbaToBgra = function(bytes) {
	if(!(bytes != null)) {
		throw new js__$Boot_HaxeError("FAIL: bytes != null");
	}
	var actual = bytes.length % 4;
	var expected = 0;
	if(actual != expected) {
		throw new js__$Boot_HaxeError("FAIL: values are not equal (expected: " + expected + ", actual: " + actual + ")");
	}
	var length = bytes.length;
	var i = 0;
	while(i < length) {
		var r = bytes.b[i];
		var g = bytes.b[i + 1];
		var b = bytes.b[i + 2];
		var a = bytes.b[i + 3];
		bytes.b[i] = b;
		bytes.b[i + 1] = g;
		bytes.b[i + 2] = r;
		bytes.b[i + 3] = a;
		i += 4;
	}
	return bytes;
};
var bitmap_Blend = $hxEnums["bitmap.Blend"] = { __ename__ : true, __constructs__ : ["alpha","mean","none"]
	,alpha: {_hx_index:0,__enum__:"bitmap.Blend",toString:$estr}
	,mean: {_hx_index:1,__enum__:"bitmap.Blend",toString:$estr}
	,none: {_hx_index:2,__enum__:"bitmap.Blend",toString:$estr}
};
var bitmap_PixelFormat = $hxEnums["bitmap.PixelFormat"] = { __ename__ : true, __constructs__ : ["RGBA","ARGB"]
	,RGBA: {_hx_index:0,__enum__:"bitmap.PixelFormat",toString:$estr}
	,ARGB: {_hx_index:1,__enum__:"bitmap.PixelFormat",toString:$estr}
};
var bitmap_Background = $hxEnums["bitmap.Background"] = { __ename__ : true, __constructs__ : ["bg","none"]
	,bg: {_hx_index:0,__enum__:"bitmap.Background",toString:$estr}
	,none: {_hx_index:1,__enum__:"bitmap.Background",toString:$estr}
};
var bitmap_Util = function() { };
bitmap_Util.__name__ = true;
bitmap_Util.clamp = function(value,min,max) {
	if(value < min) {
		return min;
	} else if(value > max) {
		return max;
	} else {
		return value;
	}
};
bitmap_Util.min = function(first,second) {
	if(first < second) {
		return first;
	} else {
		return second;
	}
};
bitmap_Util.max = function(first,second) {
	if(first > second) {
		return first;
	} else {
		return second;
	}
};
bitmap_Util.abs = function(value) {
	if(value < 0) {
		return -value;
	} else {
		return value;
	}
};
bitmap_Util.sgn = function(value) {
	if(value < 0) {
		return -1;
	} else if(value > 0) {
		return 1;
	} else {
		return 0;
	}
};
bitmap_Util.toRadians = function(degrees) {
	return degrees * Math.PI / 180;
};
bitmap_Util.toDegrees = function(radians) {
	return radians * 180 / Math.PI;
};
bitmap_Util.random = function(lower,upper) {
	return Math.round((upper - lower) * Math.random() + lower);
};
bitmap_Util.randomIntArray = function(length,lower,upper,noRepeat) {
	if(noRepeat == null) {
		noRepeat = false;
	}
	if(!(length < upper - lower + 1)) {
		throw new js__$Boot_HaxeError("FAIL: length < upper - lower + 1");
	}
	var a = [];
	var r = Math.round((upper - lower) * Math.random() + lower);
	var _g = 0;
	var _g1 = length;
	while(_g < _g1) {
		var i = _g++;
		while(a.filter(function(n) {
			return n == r;
		}).length != 0) r = Math.round((upper - lower) * Math.random() + lower);
		a.push(r);
	}
	return a;
};
bitmap_Util.randomRectangle = function(r) {
	var w = r.width / 2;
	var h = r.height / 2;
	return { x : Math.round(w * Math.random()), y : Math.round(h * Math.random()), width : Math.round(w * Math.random()), height : Math.round(h * Math.random())};
};
bitmap_Util.multiply = function(a,b) {
	var aNumRows = a.length;
	var aNumCols = a[0].length;
	var bNumRows = b.length;
	var bNumCols = b[0].length;
	var _g = [];
	var _g1 = 0;
	var _g2 = aNumRows;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push([i * 1.0]);
	}
	var m = _g;
	var _g3 = 0;
	var _g4 = aNumRows;
	while(_g3 < _g4) {
		var r = _g3++;
		var _g31 = [];
		var _g41 = 0;
		var _g5 = bNumRows;
		while(_g41 < _g5) {
			var i1 = _g41++;
			_g31.push(i1 * 1.0);
		}
		m[r] = _g31;
		var _g6 = 0;
		var _g7 = bNumCols;
		while(_g6 < _g7) {
			var c = _g6++;
			m[r][c] = 0.0;
			var _g61 = 0;
			var _g71 = aNumCols;
			while(_g61 < _g71) {
				var i2 = _g61++;
				m[r][c] += a[r][i2] * b[i2][c];
			}
		}
	}
	return m;
};
bitmap_Util.dist = function(x,y) {
	if(x < y) {
		return y - x;
	} else {
		return x - y;
	}
};
bitmap_Util.urlToBase64 = function(s) {
	return s.substring(s.indexOf(";base64,") + ";base64,".length);
};
bitmap_Util.randomArrayItem = function(a) {
	if(!(a != null && a.length > 0)) {
		throw new js__$Boot_HaxeError("FAIL: a != null && a.length > 0");
	}
	return a[Math.round((a.length - 1) * Math.random())];
};
bitmap_Util.minMaxElements = function(a) {
	if(a == null || a.length == 0) {
		return { min : 0, max : 0};
	}
	var min = a[0];
	var max = a[0];
	var _g = 0;
	while(_g < a.length) {
		var value = a[_g];
		++_g;
		if(min > value) {
			min = value;
		}
		if(max < value) {
			max = value;
		}
	}
	return { min : min, max : max};
};
var bitmap_support_Pako = function() { };
bitmap_support_Pako.__name__ = true;
var bitmap_support_StructureTools = function() { };
bitmap_support_StructureTools.__name__ = true;
bitmap_support_StructureTools.assign = function(o1,o2,o3) {
	var fields = Reflect.fields(o1).concat(Reflect.fields(o2)).concat(Reflect.fields(o3));
	var _g = 0;
	while(_g < fields.length) {
		var f = fields[_g];
		++_g;
		var v = Reflect.field(o3,f) || Reflect.field(o2,f) || Reflect.field(o1,f);
		o1[f] = v;
	}
	return o1;
};
var bitmap_support_ZipSupport = function() { };
bitmap_support_ZipSupport.__name__ = true;
bitmap_support_ZipSupport.haxeZipCompressJsSupport = function() {
	if(bitmap_support_ZipSupport.haxeZipCompressJsSupportOnce) {
		return;
	}
	bitmap_support_ZipSupport.haxeZipCompressJsSupportOnce = true;
	var pakoJs = bitmap_support_Pako.js;
	eval(pakoJs);
	haxe_zip_Compress.run = function(bytes,level) {
		if(level == null) {
			level = 9;
		}
		var data = bytes.b.bufferValue;
		var data1 = pako.deflate(data,{ level : level});
		return haxe_io_Bytes.ofData(data1);
	};
};
var bitmap_transformation_Affine = function() {
	var matrix = bitmap_transformation_Affine.identity();
	this.a = matrix.a;
	this.b = matrix.b;
	this.c = matrix.c;
	this.d = matrix.d;
	this.e = matrix.e;
	this.f = matrix.f;
};
bitmap_transformation_Affine.__name__ = true;
bitmap_transformation_Affine.identity = function() {
	return { a : 1.0, b : 0.0, c : 0.0, d : 1.0, e : 0.0, f : 0.0};
};
bitmap_transformation_Affine.prototype = {
	applyToPoint: function(x,y) {
		return { x : x * this.a + y * this.c + this.e, y : x * this.b + y * this.d + this.f};
	}
	,transform: function(o) {
		var matrix = o.matrix != null ? o.matrix : o.affine.getMatrix();
		this.a = matrix.a;
		this.b = matrix.b;
		this.c = matrix.c;
		this.d = matrix.d;
		this.e = matrix.e;
		this.f = matrix.f;
		var output = o.output != null && o.output != o.bitmap ? o.output : o.bitmap.clone(o.bg == bitmap_Background.none ? null : true);
		var region = o.region == null ? output.bounds() : o.region;
		var _g = region.y;
		var _g1 = region.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = region.x;
			var _g11 = region.width;
			while(_g2 < _g11) {
				var x = _g2++;
				var p_x = x * this.a + y * this.c + this.e;
				var p_y = x * this.b + y * this.d + this.f;
				if(p_x >= 0 && p_x < output.width && p_y >= 0 && p_y < output.height) {
					var x2 = Math.floor(p_x);
					var y2 = Math.floor(p_y);
					if(o.precision && o.bg != bitmap_Background.none) {
						if(output.get(x2,y2,true) != o.bitmap.bg) {
							x2 = Math.round(p_x);
						}
						if(output.get(x2,y2,true) != o.bitmap.bg) {
							y2 = Math.round(p_y);
						}
					}
					output.set(x2,y2,o.bitmap.get(x,y),true);
				}
			}
		}
		if(o.output == o.bitmap) {
			o.output.copyFrom(output,region,region);
		}
		return { bitmap : output, affine : this};
	}
	,transformMatrix: function(a2,b2,c2,d2,e2,f2) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var e1 = this.e;
		var f1 = this.f;
		this.a = a1 * a2 + c1 * b2;
		this.b = b1 * a2 + d1 * b2;
		this.c = a1 * c2 + c1 * d2;
		this.d = b1 * c2 + d1 * d2;
		this.e = a1 * e2 + c1 * f2 + e1;
		this.f = b1 * e2 + d1 * f2 + f1;
		return this;
	}
	,assign: function(m) {
		this.a = m.a;
		this.b = m.b;
		this.c = m.c;
		this.d = m.d;
		this.e = m.e;
		this.f = m.f;
		return this;
	}
	,getMatrix: function() {
		return { a : this.a, b : this.b, c : this.c, d : this.d, e : this.e, f : this.f};
	}
	,isIdentity: function() {
		if(this.a == 1 && this.b == 0 && this.c == 0 && this.d == 1 && this.e == 0) {
			return this.f == 0;
		} else {
			return false;
		}
	}
	,interpolate: function(m2,t) {
		var m = { a : 0.0, b : 0.0, c : 0.0, d : 0.0, e : 0.0, f : 0.0};
		m.a = this.a + (m2.a - this.a) * t;
		m.b = this.b + (m2.b - this.b) * t;
		m.c = this.c + (m2.c - this.c) * t;
		m.d = this.d + (m2.d - this.d) * t;
		m.e = this.e + (m2.e - this.e) * t;
		m.f = this.f + (m2.f - this.f) * t;
		return m;
	}
	,rotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		return this.transformMatrix(cos,sin,-sin,cos,0,0);
	}
	,rotateDeg: function(angle) {
		return this.rotate(angle * 0.017453292519943295);
	}
	,translate: function(tx,ty) {
		return this.transformMatrix(1,0,0,1,tx,ty);
	}
	,translateX: function(tx) {
		return this.transformMatrix(1,0,0,1,tx,0);
	}
	,translateY: function(ty) {
		return this.transformMatrix(1,0,0,1,0,ty);
	}
	,flipY: function() {
		return this.transformMatrix(1.0,0.0,0.0,-1.0,0.0,0.0);
	}
	,flipX: function() {
		return this.transformMatrix(-1.0,0.0,0.0,1.0,0.0,0.0);
	}
	,scale: function(sx,sy) {
		this.transformMatrix(sx,0,0,sy,0,0);
		return this;
	}
	,scaleX: function(sx) {
		this.transformMatrix(sx,0,0,1,0,0);
		return this;
	}
	,scaleY: function(sy) {
		return this.transformMatrix(1,0,0,sy,0,0);
	}
	,skew: function(sx,sy) {
		return this.transformMatrix(1,sy,sx,1,0,0);
	}
	,skewX: function(sx) {
		return this.transformMatrix(1,0,sx,1,0,0);
	}
	,skewY: function(sy) {
		return this.transformMatrix(1,sy,0,1,0,0);
	}
	,applyToPoints: function(points) {
		var i = 0;
		var p;
		var mxPoints = [];
		var l = points.length;
		while(i < l) {
			var p2 = points[i++];
			var x = p2.x;
			var y = p2.y;
			p = { x : x * this.a + y * this.c + this.e, y : x * this.b + y * this.d + this.f};
			mxPoints.push(p);
		}
		return mxPoints;
	}
	,applyToArray: function(points) {
		var i = 0;
		var p_y;
		var p_x;
		var l = points.length;
		var this1 = new Int32Array(l);
		var mxPoints = this1;
		while(i < l) {
			var x = points[i];
			var y = points[i + 1];
			p_x = x * this.a + y * this.c + this.e;
			p_y = x * this.b + y * this.d + this.f;
			mxPoints[i++] = Math.round(p_x) | 0;
			mxPoints[i++] = Math.round(p_y) | 0;
		}
		return mxPoints;
	}
};
var bitmap_transformation_Colors = function(b) {
	this.bitmap = b;
};
bitmap_transformation_Colors.__name__ = true;
bitmap_transformation_Colors.prototype = {
	blend: function(o) {
		throw new js__$Boot_HaxeError("todo");
	}
	,filter: function(o) {
		o.bitmap = o.bitmap == null ? this.bitmap : o.bitmap;
		var output = o.output == null ? o.bitmap.clone() : o.output;
		var region = o.region == null ? output.bounds() : o.region;
		var _g = region.y;
		var _g1 = region.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = region.x;
			var _g11 = region.width;
			while(_g2 < _g11) {
				var x = _g2++;
				var c = o.bitmap.get(x,y);
				o.red = o.red == null ? { a : 1.0, c : 0.0} : o.red;
				o.green = o.green == null ? { a : 1.0, c : 0.0} : o.green;
				o.blue = o.blue == null ? { a : 1.0, c : 0.0} : o.blue;
				o.alpha = o.alpha == null ? { a : 1.0, c : 0.0} : o.alpha;
				var red = Math.round((c >> 24 & 255) * o.red.a + o.red.c);
				var green = Math.round((c >> 16 & 255) * o.green.a + o.green.c);
				var blue = Math.round((c >> 8 & 255) * o.blue.a + o.blue.c);
				var alpha = Math.round((c & 255) * o.alpha.a + o.alpha.c);
				var c2 = ((red < 0 ? 0 : red > 255 ? 255 : red) << 24) + ((green < 0 ? 0 : green > 255 ? 255 : green) << 16) + ((blue < 0 ? 0 : blue > 255 ? 255 : blue) << 8) + (alpha < 0 ? 0 : alpha > 255 ? 255 : alpha);
				output.set(x,y,c2);
			}
		}
		return output;
	}
};
var bitmap_transformation_Convolution = function() { };
bitmap_transformation_Convolution.__name__ = true;
bitmap_transformation_Convolution.convolve = function(o) {
	if(!(o.bitmap != o.output)) {
		throw new js__$Boot_HaxeError("FAIL: o.bitmap != o.output");
	}
	if(!(o.output == null || o.bitmap.width == o.output.width && o.bitmap.height == o.output.height)) {
		throw new js__$Boot_HaxeError("FAIL: o.output == null || o.bitmap.width == o.output.width && o.bitmap.height == o.output.height");
	}
	var output = o.output == null ? o.bitmap.clone() : o.output;
	var data = o.bitmap;
	var width = o.bitmap.width;
	var height = o.bitmap.height;
	var matrix = o.kernel;
	var w = matrix[0].length;
	var h = matrix.length;
	var half = Math.floor(h / 2);
	var factor = o.factor == null ? 1.0 : o.factor;
	var bias = o.bias == null ? 0.0 : o.bias;
	var region = o.region == null ? output.bounds() : o.region;
	var _g = region.y;
	var _g1 = region.height;
	while(_g < _g1) {
		var y = _g++;
		var _g2 = region.x;
		var _g11 = region.width;
		while(_g2 < _g11) {
			var x = _g2++;
			var px = (y * width + x) * 4;
			var r = 0.0;
			var g = 0.0;
			var b = 0.0;
			var _g3 = 0;
			var _g12 = h;
			while(_g3 < _g12) {
				var cy = _g3++;
				var _g4 = 0;
				var _g13 = w;
				while(_g4 < _g13) {
					var cx = _g4++;
					var cpx = Math.floor(((y + (cy - half)) * width + (x + (cx - half))) * 4);
					var ir = cpx >= 0 && cpx < data.data.length ? data.data.b[cpx] : 0;
					var ig = cpx >= 0 && cpx + 1 < data.data.length ? data.data.b[cpx + 1] : 0;
					var ib = cpx >= 0 && cpx + 2 < data.data.length ? data.data.b[cpx + 2] : 0;
					ir = ir == null ? 0 : ir;
					ig = ig == null ? 0 : ig;
					ib = ib == null ? 0 : ib;
					r += ir * matrix[cy][cx];
					g += ig * matrix[cy][cx];
					b += ib * matrix[cy][cx];
				}
			}
			var value = Math.round(factor * r + bias);
			output.data.b[px] = value < 0 ? 0 : value > 255 ? 255 : value;
			var value1 = Math.round(factor * g + bias);
			output.data.b[px + 1] = value1 < 0 ? 0 : value1 > 255 ? 255 : value1;
			var value2 = Math.round(factor * b + bias);
			output.data.b[px + 2] = value2 < 0 ? 0 : value2 > 255 ? 255 : value2;
			output.data.b[px + 3] = data.data.b[px + 3];
		}
	}
	return output;
};
bitmap_transformation_Convolution.blur = function(size,bias,output) {
	if(bias == null) {
		bias = 0.0;
	}
	if(size == null) {
		size = 3;
	}
	return { kernel : bitmap_transformation_Convolution.blurKernel(size,bias), bias : bias, factor : 1 / (size * size), bitmap : null, output : output, region : null};
};
bitmap_transformation_Convolution.blurKernel = function(size,bias) {
	if(bias == null) {
		bias = 0.0;
	}
	if(size == null) {
		size = 3;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = size;
	while(_g1 < _g2) {
		var i = _g1++;
		var _g11 = [];
		var _g21 = 0;
		var _g3 = size;
		while(_g21 < _g3) {
			var i1 = _g21++;
			_g11.push(0.0);
		}
		_g.push(_g11);
	}
	var k = _g;
	var _g31 = 0;
	var _g4 = size;
	while(_g31 < _g4) {
		var i2 = _g31++;
		var _g32 = 0;
		var _g41 = size;
		while(_g32 < _g41) {
			var j = _g32++;
			k[i2][j] = 1.0;
		}
	}
	return k;
};
bitmap_transformation_Convolution.fBlur = function(size,bias,output) {
	if(bias == null) {
		bias = 0.0;
	}
	if(size == null) {
		size = 4;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = size;
	while(_g1 < _g2) {
		var i = _g1++;
		var _g11 = [];
		var _g21 = 0;
		var _g3 = size;
		while(_g21 < _g3) {
			var i1 = _g21++;
			_g11.push(0.0);
		}
		_g.push(_g11);
	}
	var k = _g;
	var _g31 = 0;
	var _g4 = size;
	while(_g31 < _g4) {
		var i2 = _g31++;
		var _g32 = 0;
		var _g41 = size;
		while(_g32 < _g41) {
			var j = _g32++;
			if(i2 == 0 || j == 0 || i2 == size - 1 || j == size - 1) {
				k[i2][j] = 1.0;
			} else {
				k[i2][j] = 0;
			}
		}
	}
	return { kernel : k, bias : bias, factor : 1 / (size + 1), bitmap : null, output : output, region : null};
};
bitmap_transformation_Convolution.sharp = function(factor,bias,output) {
	if(bias == null) {
		bias = 0.0;
	}
	if(factor == null) {
		factor = 1.0;
	}
	var k = [[-0.111111111111111105,-0.111111111111111105,-0.111111111111111105,-0.111111111111111105],[-0.111111111111111105,factor,factor,-0.111111111111111105],[-0.111111111111111105,factor,factor,-0.111111111111111105],[-0.111111111111111105,-0.111111111111111105,-0.111111111111111105,-0.111111111111111105]];
	return { kernel : k, bias : bias, factor : factor, bitmap : null, output : output, region : null};
};
var bitmap_transformation_Pixelize = function() {
};
bitmap_transformation_Pixelize.__name__ = true;
bitmap_transformation_Pixelize.prototype = {
	transform: function(t) {
		var b = t.output != null ? t.output : t.bitmap.clone();
		var a = t.bitmap;
		var region2 = t.region == null ? a.bounds() : t.region;
		var xStep = Math.round(region2.width / t.width) | 0;
		var yStep = Math.round(region2.height / t.height) | 0;
		var _g = 0;
		var _g1 = t.width;
		while(_g < _g1) {
			var x = _g++;
			var _g2 = 0;
			var _g11 = t.height;
			while(_g2 < _g11) {
				var y = _g2++;
				var minXStep = xStep * x + xStep >= region2.width ? region2.width - 1 - xStep * x : xStep;
				var minYStep = yStep * y + yStep >= region2.height ? region2.height - 1 - yStep * y : yStep;
				var region = { x : xStep * x + region2.x, y : yStep * y + region2.y, width : minXStep, height : minYStep};
				var c = bitmap_ColorUtil.average(a,region,t.alpha);
				var tmp_1 = region;
				var tmp_2_c = c;
				var tmp_2_fill = true;
				var tmp_2_blend = t.blend;
				var tmp_1_y = tmp_1.y;
				var tmp_1_x = tmp_1.x;
				var tmp_1_width = tmp_1.width;
				var tmp_1_height = tmp_1.height;
				var tmp_1_fill = tmp_2_fill;
				var tmp_1_c = tmp_2_c;
				var tmp_1_blend = tmp_2_blend;
				var tmp_2_x = xStep * x + region2.x;
				var tmp_2_y = yStep * y + region2.y;
				var tmp_2_width = minXStep;
				var tmp_2_height = minYStep;
				b.draw.rectangle({ y : tmp_2_y, x : tmp_2_x, width : tmp_2_width, height : tmp_2_height, fill : tmp_1_fill, c : tmp_1_c, blend : tmp_1_blend});
			}
		}
		return b;
	}
};
var bitmap_transformation_Transform = function(b) {
	this.bitmap = b;
};
bitmap_transformation_Transform.__name__ = true;
bitmap_transformation_Transform.prototype = {
	pixelize: function(t) {
		t.bitmap = this.bitmap;
		var b = new bitmap_transformation_Pixelize().transform(t);
		return b;
	}
	,convolve: function(t) {
		t.bitmap = this.bitmap;
		var b = bitmap_transformation_Convolution.convolve(t);
		return b;
	}
	,affine: function(t) {
		if(!(t.matrix != null || t.affine != null)) {
			throw new js__$Boot_HaxeError("FAIL: t.matrix != null || t.affine != null");
		}
		t.bitmap = this.bitmap;
		var affine;
		if(t.affine == null) {
			affine = new bitmap_transformation_Affine();
			affine.assign(t.matrix);
		} else {
			affine = t.affine;
		}
		var result = affine.transform(t);
		return result;
	}
};
var examples_AffineTransformation = function() {
};
examples_AffineTransformation.__name__ = true;
examples_AffineTransformation.prototype = {
	run: function(bitmap1,outputs) {
		bitmap1.bg = -16776994;
		var result1 = bitmap1.transform.affine({ affine : new bitmap_transformation_Affine().scale(0.7,0.6), bg : bitmap_Background.bg});
		outputs[1].src = result1.bitmap.io.toDataUrl();
		var result2 = bitmap1.transform.affine({ affine : new bitmap_transformation_Affine().scale(0.5,0.3).translate(222,211).rotateDeg(35.6)});
		outputs[2].src = result2.bitmap.io.toDataUrl();
		var result3 = bitmap1.transform.affine({ matrix : { a : 0.4, b : 0.5, c : 0.2, d : 1.5, e : 2.0, f : 3.0}});
		outputs[3].src = result3.bitmap.io.toDataUrl();
	}
	,getSource: function() {
		return haxe_Resource.getString("AffineTransformation");
	}
};
var examples_Colors = function() {
};
examples_Colors.__name__ = true;
examples_Colors.prototype = {
	run: function(bitmap,outputs) {
		var result0 = bitmap.color.filter({ alpha : { a : 0.2, c : 0}});
		outputs[0].src = result0.io.toDataUrl();
		var result1 = bitmap.color.filter({ red : { a : 1.5, c : 2}, green : { a : 1.0, c : -15}, alpha : { a : 0.6, c : 0}});
		outputs[1].src = result1.io.toDataUrl();
	}
	,getSource: function() {
		return haxe_Resource.getString("Colors");
	}
};
var examples_Convolutions = function() {
};
examples_Convolutions.__name__ = true;
examples_Convolutions.prototype = {
	run: function(bitmap1,outputs) {
		var result0 = bitmap1.transform.convolve(bitmap_transformation_Convolution.blur(7));
		outputs[0].src = result0.io.toDataUrl();
		var result1 = bitmap1.transform.convolve(bitmap_transformation_Convolution.sharp(0.7,0.1));
		outputs[1].src = result1.io.toDataUrl();
		var edgy = [[0.0,-1.0,0.0],[-1.0,4.0,-1.0],[0.0,-1.0,0.0]];
		var result3 = bitmap1.transform.convolve({ kernel : edgy, bias : 0.2, factor : 1.1});
		outputs[3].src = result3.io.toDataUrl();
	}
	,getSource: function() {
		return haxe_Resource.getString("Convolutions");
	}
};
var examples_Pixelize = function() {
};
examples_Pixelize.__name__ = true;
examples_Pixelize.prototype = {
	run: function(bitmap,outputs) {
		var result0 = bitmap.transform.pixelize({ width : 100, height : 90});
		outputs[0].src = result0.io.toDataUrl();
		outputs[1].src = bitmap.transform.pixelize({ width : 70, height : 60}).io.toDataUrl();
		outputs[2].src = bitmap.transform.pixelize({ width : 40, height : 34}).io.toDataUrl();
		outputs[3].src = bitmap.transform.pixelize({ width : 28, height : 25}).io.toDataUrl();
		outputs[4].src = bitmap.transform.pixelize({ width : 19, height : 15}).io.toDataUrl();
	}
	,getSource: function() {
		return haxe_Resource.getString("Pixelize");
	}
};
var examples_Shapes = function() {
};
examples_Shapes.__name__ = true;
examples_Shapes.prototype = {
	run: function(bitmap1,outputs) {
		bitmap1.draw.rectangle2(20,40,100,50,-579899582,true,{ type : bitmap_Blend.mean});
		bitmap1.draw.triangle(220,30,300,150,90,210,366178114,true,{ type : bitmap_Blend.mean});
		bitmap1.draw.line(12,211,88,1,353751974);
		outputs[0].src = bitmap1.io.toDataUrl();
	}
	,getSource: function() {
		return haxe_Resource.getString("Shapes");
	}
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__ : true, __constructs__ : ["ColGrey","ColTrue","ColIndexed"]
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__ : true, __constructs__ : ["CEnd","CHeader","CData","CPalette","CUnknown"]
	,CEnd: {_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["id","data"],$_)
};
var format_png_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.checkCRC = true;
};
format_png_Reader.__name__ = true;
format_png_Reader.prototype = {
	read: function() {
		var b = 137;
		if(this.i.readByte() != b) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b1 = 80;
		if(this.i.readByte() != b1) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b2 = 78;
		if(this.i.readByte() != b2) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b3 = 71;
		if(this.i.readByte() != b3) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b4 = 13;
		if(this.i.readByte() != b4) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b5 = 10;
		if(this.i.readByte() != b5) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b6 = 26;
		if(this.i.readByte() != b6) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b7 = 10;
		if(this.i.readByte() != b7) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var l = new haxe_ds_List();
		while(true) {
			var c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	,readHeader: function(i) {
		i.set_bigEndian(true);
		var width = i.readInt32();
		var height = i.readInt32();
		var colbits = i.readByte();
		var color = i.readByte();
		var color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw new js__$Boot_HaxeError("Unknown color model " + color + ":" + colbits);
		}
		var compress = i.readByte();
		var filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	,readChunk: function() {
		var dataLen = this.i.readInt32();
		var id = this.i.readString(4);
		var data = this.i.read(dataLen);
		var crc = this.i.readInt32();
		if(this.checkCRC) {
			var c_crc = -1;
			var tmp = (c_crc ^ HxOverrides.cca(id,0)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
			var tmp1 = (c_crc ^ HxOverrides.cca(id,1)) & 255;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp1;
			var tmp2 = (c_crc ^ HxOverrides.cca(id,2)) & 255;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp2;
			var tmp3 = (c_crc ^ HxOverrides.cca(id,3)) & 255;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp3;
			var b = data.b.bufferValue;
			var _g = 0;
			var _g1 = data.length;
			while(_g < _g1) {
				var i = _g++;
				var tmp4 = (c_crc ^ b.bytes[i]) & 255;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
				c_crc = c_crc >>> 8 ^ tmp4;
			}
			if((c_crc ^ -1) != crc) {
				throw new js__$Boot_HaxeError("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
};
var format_png_Tools = function() { };
format_png_Tools.__name__ = true;
format_png_Tools.getHeader = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 1) {
			var h = c.h;
			return h;
		}
	}
	throw new js__$Boot_HaxeError("Header not found");
};
format_png_Tools.getPalette = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 3) {
			var b = c.b;
			return b;
		}
	}
	return null;
};
format_png_Tools.filter = function(data,x,y,stride,prev,p,numChannels) {
	if(numChannels == null) {
		numChannels = 4;
	}
	var b = y == 0 ? 0 : data.b[p - stride];
	var c = x == 0 || y == 0 ? 0 : data.b[p - stride - numChannels];
	var k = prev + b - c;
	var pa = k - prev;
	if(pa < 0) {
		pa = -pa;
	}
	var pb = k - b;
	if(pb < 0) {
		pb = -pb;
	}
	var pc = k - c;
	if(pc < 0) {
		pc = -pc;
	}
	if(pa <= pb && pa <= pc) {
		return prev;
	} else if(pb <= pc) {
		return b;
	} else {
		return c;
	}
};
format_png_Tools.reverseBytes = function(b) {
	var p = 0;
	var _g = 0;
	var _g1 = b.length >> 2;
	while(_g < _g1) {
		var i = _g++;
		var b1 = b.b[p];
		var g = b.b[p + 1];
		var r = b.b[p + 2];
		var a = b.b[p + 3];
		b.b[p++] = a;
		b.b[p++] = r;
		b.b[p++] = g;
		b.b[p++] = b1;
	}
};
format_png_Tools.extractGrey = function(d) {
	var h = format_png_Tools.getHeader(d);
	var grey = new haxe_io_Bytes(new ArrayBuffer(h.width * h.height));
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw new js__$Boot_HaxeError("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var _g1 = h.color;
	if(_g1._hx_index == 0) {
		var alpha = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var rinc = alpha ? 2 : 1;
		var _g11 = 0;
		var _g2 = h.height;
		while(_g11 < _g2) {
			var y = _g11++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				var _g12 = 0;
				var _g21 = width;
				while(_g12 < _g21) {
					var x = _g12++;
					var v = data.b[r];
					r += rinc;
					grey.b[w++] = v;
				}
				break;
			case 1:
				var cv = 0;
				var _g13 = 0;
				var _g22 = width;
				while(_g13 < _g22) {
					var x1 = _g13++;
					cv += data.b[r];
					r += rinc;
					grey.b[w++] = cv;
				}
				break;
			case 2:
				var stride1 = y == 0 ? 0 : width;
				var _g14 = 0;
				var _g23 = width;
				while(_g14 < _g23) {
					var x2 = _g14++;
					var v1 = data.b[r] + grey.b[w - stride1];
					r += rinc;
					grey.b[w++] = v1;
				}
				break;
			case 3:
				var cv1 = 0;
				var stride2 = y == 0 ? 0 : width;
				var _g15 = 0;
				var _g24 = width;
				while(_g15 < _g24) {
					var x3 = _g15++;
					cv1 = data.b[r] + (cv1 + grey.b[w - stride2] >> 1) & 255;
					r += rinc;
					grey.b[w++] = cv1;
				}
				break;
			case 4:
				var stride3 = width;
				var cv2 = 0;
				var _g16 = 0;
				var _g25 = width;
				while(_g16 < _g25) {
					var x4 = _g16++;
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b1 = y == 0 ? 0 : grey.b[w - stride3];
					var c1 = x4 == 0 || y == 0 ? 0 : grey.b[w - stride3 - numChannels];
					var k = cv2 + b1 - c1;
					var pa = k - cv2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b1;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c1;
					if(pc < 0) {
						pc = -pc;
					}
					cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b1 : c1) + data.b[r] & 255;
					r += rinc;
					grey.b[w++] = cv2;
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f);
			}
		}
	} else {
		throw new js__$Boot_HaxeError("Unsupported color mode");
	}
	return grey;
};
format_png_Tools.extract32 = function(d,bytes,flipY) {
	var h = format_png_Tools.getHeader(d);
	var bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw new js__$Boot_HaxeError("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var lineDelta = 0;
	if(flipY) {
		lineDelta = -h.width * 8;
		w = (h.height - 1) * (h.width * 4);
	}
	var flipY1 = flipY ? -1 : 1;
	var _g1 = h.color;
	switch(_g1._hx_index) {
	case 0:
		var alpha = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var alphvaIdx = -1;
		if(!alpha) {
			var _g1_head = d.h;
			while(_g1_head != null) {
				var val1 = _g1_head.item;
				_g1_head = _g1_head.next;
				var t = val1;
				if(t._hx_index == 4) {
					if(t.id == "tRNS") {
						var data1 = t.data;
						if(data1.length >= 2) {
							alphvaIdx = data1.b[1];
						}
						break;
					}
				}
			}
		}
		var _g11 = 0;
		var _g2 = h.height;
		while(_g11 < _g2) {
			var y = _g11++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g12 = 0;
					var _g21 = width;
					while(_g12 < _g21) {
						var x = _g12++;
						var v = data.b[r++];
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = data.b[r++];
					}
				} else {
					var _g13 = 0;
					var _g22 = width;
					while(_g13 < _g22) {
						var x1 = _g13++;
						var v1 = data.b[r++];
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 1:
				var cv = 0;
				var ca = 0;
				if(alpha) {
					var _g14 = 0;
					var _g23 = width;
					while(_g14 < _g23) {
						var x2 = _g14++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						ca += data.b[r++];
						bgra.b[w++] = ca;
					}
				} else {
					var _g15 = 0;
					var _g24 = width;
					while(_g15 < _g24) {
						var x3 = _g15++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 2:
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g16 = 0;
					var _g25 = width;
					while(_g16 < _g25) {
						var x4 = _g16++;
						var v2 = data.b[r++] + bgra.b[w - stride1];
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = data.b[r++] + bgra.b[w - stride1];
					}
				} else {
					var _g17 = 0;
					var _g26 = width;
					while(_g17 < _g26) {
						var x5 = _g17++;
						var v3 = data.b[r++] + bgra.b[w - stride1];
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 3:
				var cv1 = 0;
				var ca1 = 0;
				var stride2 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g18 = 0;
					var _g27 = width;
					while(_g18 < _g27) {
						var x6 = _g18++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						ca1 = data.b[r++] + (ca1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = ca1;
					}
				} else {
					var _g19 = 0;
					var _g28 = width;
					while(_g19 < _g28) {
						var x7 = _g19++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 4:
				var stride3 = width * 4 * flipY1;
				var cv2 = 0;
				var ca2 = 0;
				if(alpha) {
					var _g110 = 0;
					var _g29 = width;
					while(_g110 < _g29) {
						var x8 = _g110++;
						var b1 = y == 0 ? 0 : bgra.b[w - stride3];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k = cv2 + b1 - c1;
						var pa = k - cv2;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b1;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c1;
						if(pc < 0) {
							pc = -pc;
						}
						var pos = r++;
						cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b1 : c1) + data.b[pos] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						var b2 = y == 0 ? 0 : bgra.b[w - stride3];
						var c2 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k1 = ca2 + b2 - c2;
						var pa1 = k1 - ca2;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b2;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c2;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						var pos1 = r++;
						ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b2 : c2) + data.b[pos1] & 255;
						bgra.b[w++] = ca2;
					}
				} else {
					var _g111 = 0;
					var _g210 = width;
					while(_g111 < _g210) {
						var x9 = _g111++;
						var b3 = y == 0 ? 0 : bgra.b[w - stride3];
						var c3 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k2 = cv2 + b3 - c3;
						var pa2 = k2 - cv2;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b3;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c3;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						var pos2 = r++;
						cv2 = (pa2 <= pb2 && pa2 <= pc2 ? cv2 : pb2 <= pc2 ? b3 : c3) + data.b[pos2] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 1:
		var alpha1 = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width1 = h.width;
		var stride4 = (alpha1 ? 4 : 3) * width1 + 1;
		if(data.length < h.height * stride4) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var alphaRed = -1;
		var alphaGreen = -1;
		var alphaBlue = -1;
		if(!alpha1) {
			var _g1_head1 = d.h;
			while(_g1_head1 != null) {
				var val2 = _g1_head1.item;
				_g1_head1 = _g1_head1.next;
				var t1 = val2;
				if(t1._hx_index == 4) {
					if(t1.id == "tRNS") {
						var data2 = t1.data;
						if(data2.length >= 6) {
							alphaRed = data2.b[1];
							alphaGreen = data2.b[3];
							alphaBlue = data2.b[5];
						}
						break;
					}
				}
			}
		}
		var cr = 0;
		var cg = 0;
		var cb = 0;
		var ca3 = 0;
		var _g112 = 0;
		var _g211 = h.height;
		while(_g112 < _g211) {
			var y1 = _g112++;
			var f1 = data.b[r++];
			switch(f1) {
			case 0:
				if(alpha1) {
					var _g113 = 0;
					var _g212 = width1;
					while(_g113 < _g212) {
						var x10 = _g113++;
						bgra.b[w++] = data.b[r + 2];
						bgra.b[w++] = data.b[r + 1];
						bgra.b[w++] = data.b[r];
						bgra.b[w++] = data.b[r + 3];
						r += 4;
					}
				} else {
					var _g114 = 0;
					var _g213 = width1;
					while(_g114 < _g213) {
						var x11 = _g114++;
						cb = data.b[r + 2];
						bgra.b[w++] = cb;
						cg = data.b[r + 1];
						bgra.b[w++] = cg;
						cr = data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 1:
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				if(alpha1) {
					var _g115 = 0;
					var _g214 = width1;
					while(_g115 < _g214) {
						var x12 = _g115++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						ca3 += data.b[r + 3];
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g116 = 0;
					var _g215 = width1;
					while(_g116 < _g215) {
						var x13 = _g116++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 2:
				var stride5 = y1 == 0 ? 0 : width1 * 4 * flipY1;
				if(alpha1) {
					var _g117 = 0;
					var _g216 = width1;
					while(_g117 < _g216) {
						var x14 = _g117++;
						bgra.b[w] = data.b[r + 2] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r + 1] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r + 3] + bgra.b[w - stride5];
						++w;
						r += 4;
					}
				} else {
					var _g118 = 0;
					var _g217 = width1;
					while(_g118 < _g217) {
						var x15 = _g118++;
						cb = data.b[r + 2] + bgra.b[w - stride5];
						bgra.b[w] = cb;
						++w;
						cg = data.b[r + 1] + bgra.b[w - stride5];
						bgra.b[w] = cg;
						++w;
						cr = data.b[r] + bgra.b[w - stride5];
						bgra.b[w] = cr;
						++w;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 3:
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				var stride6 = y1 == 0 ? 0 : width1 * 4 * flipY1;
				if(alpha1) {
					var _g119 = 0;
					var _g218 = width1;
					while(_g119 < _g218) {
						var x16 = _g119++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cr;
						ca3 = data.b[r + 3] + (ca3 + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g120 = 0;
					var _g219 = width1;
					while(_g120 < _g219) {
						var x17 = _g120++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 4:
				var stride7 = width1 * 4 * flipY1;
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				if(alpha1) {
					var _g121 = 0;
					var _g220 = width1;
					while(_g121 < _g220) {
						var x18 = _g121++;
						var b4 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c4 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k3 = cb + b4 - c4;
						var pa3 = k3 - cb;
						if(pa3 < 0) {
							pa3 = -pa3;
						}
						var pb3 = k3 - b4;
						if(pb3 < 0) {
							pb3 = -pb3;
						}
						var pc3 = k3 - c4;
						if(pc3 < 0) {
							pc3 = -pc3;
						}
						cb = (pa3 <= pb3 && pa3 <= pc3 ? cb : pb3 <= pc3 ? b4 : c4) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b5 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c5 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k4 = cg + b5 - c5;
						var pa4 = k4 - cg;
						if(pa4 < 0) {
							pa4 = -pa4;
						}
						var pb4 = k4 - b5;
						if(pb4 < 0) {
							pb4 = -pb4;
						}
						var pc4 = k4 - c5;
						if(pc4 < 0) {
							pc4 = -pc4;
						}
						cg = (pa4 <= pb4 && pa4 <= pc4 ? cg : pb4 <= pc4 ? b5 : c5) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b6 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c6 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k5 = cr + b6 - c6;
						var pa5 = k5 - cr;
						if(pa5 < 0) {
							pa5 = -pa5;
						}
						var pb5 = k5 - b6;
						if(pb5 < 0) {
							pb5 = -pb5;
						}
						var pc5 = k5 - c6;
						if(pc5 < 0) {
							pc5 = -pc5;
						}
						cr = (pa5 <= pb5 && pa5 <= pc5 ? cr : pb5 <= pc5 ? b6 : c6) + data.b[r] & 255;
						bgra.b[w++] = cr;
						var b7 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c7 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k6 = ca3 + b7 - c7;
						var pa6 = k6 - ca3;
						if(pa6 < 0) {
							pa6 = -pa6;
						}
						var pb6 = k6 - b7;
						if(pb6 < 0) {
							pb6 = -pb6;
						}
						var pc6 = k6 - c7;
						if(pc6 < 0) {
							pc6 = -pc6;
						}
						ca3 = (pa6 <= pb6 && pa6 <= pc6 ? ca3 : pb6 <= pc6 ? b7 : c7) + data.b[r + 3] & 255;
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g122 = 0;
					var _g221 = width1;
					while(_g122 < _g221) {
						var x19 = _g122++;
						var b8 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c8 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k7 = cb + b8 - c8;
						var pa7 = k7 - cb;
						if(pa7 < 0) {
							pa7 = -pa7;
						}
						var pb7 = k7 - b8;
						if(pb7 < 0) {
							pb7 = -pb7;
						}
						var pc7 = k7 - c8;
						if(pc7 < 0) {
							pc7 = -pc7;
						}
						cb = (pa7 <= pb7 && pa7 <= pc7 ? cb : pb7 <= pc7 ? b8 : c8) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b9 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c9 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k8 = cg + b9 - c9;
						var pa8 = k8 - cg;
						if(pa8 < 0) {
							pa8 = -pa8;
						}
						var pb8 = k8 - b9;
						if(pb8 < 0) {
							pb8 = -pb8;
						}
						var pc8 = k8 - c9;
						if(pc8 < 0) {
							pc8 = -pc8;
						}
						cg = (pa8 <= pb8 && pa8 <= pc8 ? cg : pb8 <= pc8 ? b9 : c9) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b10 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c10 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k9 = cr + b10 - c10;
						var pa9 = k9 - cr;
						if(pa9 < 0) {
							pa9 = -pa9;
						}
						var pb9 = k9 - b10;
						if(pb9 < 0) {
							pb9 = -pb9;
						}
						var pc9 = k9 - c10;
						if(pc9 < 0) {
							pc9 = -pc9;
						}
						cr = (pa9 <= pb9 && pa9 <= pc9 ? cr : pb9 <= pc9 ? b10 : c10) + data.b[r] & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f1);
			}
			w += lineDelta;
		}
		break;
	case 2:
		var pal = format_png_Tools.getPalette(d);
		if(pal == null) {
			throw new js__$Boot_HaxeError("PNG Palette is missing");
		}
		var alpha2 = null;
		var _g1_head2 = d.h;
		while(_g1_head2 != null) {
			var val3 = _g1_head2.item;
			_g1_head2 = _g1_head2.next;
			var t2 = val3;
			if(t2._hx_index == 4) {
				if(t2.id == "tRNS") {
					var data3 = t2.data;
					alpha2 = data3;
					break;
				}
			}
		}
		if(alpha2 != null && alpha2.length < 1 << h.colbits) {
			var alpha21 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
			alpha21.blit(0,alpha2,0,alpha2.length);
			alpha21.fill(alpha2.length,alpha21.length - alpha2.length,255);
			alpha2 = alpha21;
		}
		var width2 = h.width;
		var stride8 = Math.ceil(width2 * h.colbits / 8) + 1;
		if(data.length < h.height * stride8) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var tmp = h.width * h.colbits;
		var rline = tmp >> 3;
		var _g222 = 0;
		var _g3 = h.height;
		while(_g222 < _g3) {
			var y2 = _g222++;
			var f2 = data.b[r++];
			if(f2 == 0) {
				r += rline;
				continue;
			}
			switch(f2) {
			case 1:
				var c11 = 0;
				var _g223 = 0;
				var _g31 = width2;
				while(_g223 < _g31) {
					var x20 = _g223++;
					var v4 = data.b[r];
					c11 += v4;
					data.b[r++] = c11 & 255;
				}
				break;
			case 2:
				var stride9 = y2 == 0 ? 0 : rline + 1;
				var _g224 = 0;
				var _g32 = width2;
				while(_g224 < _g32) {
					var x21 = _g224++;
					var v5 = data.b[r];
					data.b[r] = v5 + data.b[r - stride9];
					++r;
				}
				break;
			case 3:
				var c12 = 0;
				var stride10 = y2 == 0 ? 0 : rline + 1;
				var _g225 = 0;
				var _g33 = width2;
				while(_g225 < _g33) {
					var x22 = _g225++;
					var v6 = data.b[r];
					c12 = v6 + (c12 + data.b[r - stride10] >> 1) & 255;
					data.b[r++] = c12;
				}
				break;
			case 4:
				var stride11 = rline + 1;
				var c13 = 0;
				var _g226 = 0;
				var _g34 = width2;
				while(_g226 < _g34) {
					var x23 = _g226++;
					var v7 = data.b[r];
					var numChannels = 1;
					if(numChannels == null) {
						numChannels = 4;
					}
					var b11 = y2 == 0 ? 0 : data.b[r - stride11];
					var c14 = x23 == 0 || y2 == 0 ? 0 : data.b[r - stride11 - numChannels];
					var k10 = c13 + b11 - c14;
					var pa10 = k10 - c13;
					if(pa10 < 0) {
						pa10 = -pa10;
					}
					var pb10 = k10 - b11;
					if(pb10 < 0) {
						pb10 = -pb10;
					}
					var pc10 = k10 - c14;
					if(pc10 < 0) {
						pc10 = -pc10;
					}
					c13 = (pa10 <= pb10 && pa10 <= pc10 ? c13 : pb10 <= pc10 ? b11 : c14) + v7 & 255;
					data.b[r++] = c13;
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f2);
			}
		}
		var r1 = 0;
		if(h.colbits == 8) {
			var _g4 = 0;
			var _g5 = h.height;
			while(_g4 < _g5) {
				var y3 = _g4++;
				++r1;
				var _g41 = 0;
				var _g51 = h.width;
				while(_g41 < _g51) {
					var x24 = _g41++;
					var c15 = data.b[r1++];
					bgra.b[w++] = pal.b[c15 * 3 + 2];
					bgra.b[w++] = pal.b[c15 * 3 + 1];
					bgra.b[w++] = pal.b[c15 * 3];
					bgra.b[w++] = alpha2 != null ? alpha2.b[c15] : 255;
				}
				w += lineDelta;
			}
		} else if(h.colbits < 8) {
			var req = h.colbits;
			var mask = (1 << req) - 1;
			var _g42 = 0;
			var _g52 = h.height;
			while(_g42 < _g52) {
				var y4 = _g42++;
				++r1;
				var bits = 0;
				var nbits = 0;
				var _g43 = 0;
				var _g53 = h.width;
				while(_g43 < _g53) {
					var x25 = _g43++;
					if(nbits < req) {
						bits = bits << 8 | data.b[r1++];
						nbits += 8;
					}
					var c16 = bits >>> nbits - req & mask;
					nbits -= req;
					bgra.b[w++] = pal.b[c16 * 3 + 2];
					bgra.b[w++] = pal.b[c16 * 3 + 1];
					bgra.b[w++] = pal.b[c16 * 3];
					bgra.b[w++] = alpha2 != null ? alpha2.b[c16] : 255;
				}
				w += lineDelta;
			}
		} else {
			throw new js__$Boot_HaxeError(h.colbits + " indexed bits per pixel not supported");
		}
		break;
	}
	return bgra;
};
format_png_Tools.buildGrey = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColGrey(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildIndexed = function(width,height,data,palette,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColIndexed, interlaced : false}));
	l.add(format_png_Chunk.CPalette(palette));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgb.b[w++] = data.b[r + 2];
			rgb.b[w++] = data.b[r + 1];
			rgb.b[w++] = data.b[r];
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32ARGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 3];
			rgba.b[w++] = data.b[r];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32BGRA = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r];
			rgba.b[w++] = data.b[r + 3];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_png_Writer = function(o) {
	this.o = o;
	o.set_bigEndian(true);
};
format_png_Writer.__name__ = true;
format_png_Writer.prototype = {
	write: function(png) {
		var b = 137;
		this.o.writeByte(b);
		var b1 = 80;
		this.o.writeByte(b1);
		var b2 = 78;
		this.o.writeByte(b2);
		var b3 = 71;
		this.o.writeByte(b3);
		var b4 = 13;
		this.o.writeByte(b4);
		var b5 = 10;
		this.o.writeByte(b5);
		var b6 = 26;
		this.o.writeByte(b6);
		var b7 = 10;
		this.o.writeByte(b7);
		var _g_head = png.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var c = val;
			switch(c._hx_index) {
			case 0:
				this.writeChunk("IEND",new haxe_io_Bytes(new ArrayBuffer(0)));
				break;
			case 1:
				var h = c.h;
				var b8 = new haxe_io_BytesOutput();
				b8.set_bigEndian(true);
				b8.writeInt32(h.width);
				b8.writeInt32(h.height);
				b8.writeByte(h.colbits);
				var _g = h.color;
				var tmp;
				switch(_g._hx_index) {
				case 0:
					var alpha = _g.alpha;
					tmp = alpha ? 4 : 0;
					break;
				case 1:
					var alpha1 = _g.alpha;
					tmp = alpha1 ? 6 : 2;
					break;
				case 2:
					tmp = 3;
					break;
				}
				b8.writeByte(tmp);
				b8.writeByte(0);
				b8.writeByte(0);
				b8.writeByte(h.interlaced ? 1 : 0);
				this.writeChunk("IHDR",b8.getBytes());
				break;
			case 2:
				var d = c.b;
				this.writeChunk("IDAT",d);
				break;
			case 3:
				var b9 = c.b;
				this.writeChunk("PLTE",b9);
				break;
			case 4:
				var data = c.data;
				var id = c.id;
				this.writeChunk(id,data);
				break;
			}
		}
	}
	,writeChunk: function(id,data) {
		this.o.writeInt32(data.length);
		this.o.writeString(id);
		this.o.write(data);
		var crc_crc = -1;
		var tmp = (crc_crc ^ HxOverrides.cca(id,0)) & 255;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp;
		var tmp1 = (crc_crc ^ HxOverrides.cca(id,1)) & 255;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp1;
		var tmp2 = (crc_crc ^ HxOverrides.cca(id,2)) & 255;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp2;
		var tmp3 = (crc_crc ^ HxOverrides.cca(id,3)) & 255;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
		crc_crc = crc_crc >>> 8 ^ tmp3;
		var b = data.b.bufferValue;
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			var tmp4 = (crc_crc ^ b.bytes[i]) & 255;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			tmp4 = tmp4 >>> 1 ^ -(tmp4 & 1) & -306674912;
			crc_crc = crc_crc >>> 8 ^ tmp4;
		}
		this.o.writeInt32(crc_crc ^ -1);
	}
};
var format_tools_Deflate = function() { };
format_tools_Deflate.__name__ = true;
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var format_tools_Inflate = function() { };
format_tools_Inflate.__name__ = true;
format_tools_Inflate.run = function(bytes) {
	return haxe_zip_Uncompress.run(bytes);
};
var haxe_Resource = function() { };
haxe_Resource.__name__ = true;
haxe_Resource.getString = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return x.str;
			}
			var b = haxe_crypto_Base64.decode(x.data);
			return b.toString();
		}
	}
	return null;
};
var haxe_crypto_Adler32 = function() {
	this.a1 = 1;
	this.a2 = 0;
};
haxe_crypto_Adler32.__name__ = true;
haxe_crypto_Adler32.read = function(i) {
	var a = new haxe_crypto_Adler32();
	var a2a = i.readByte();
	var a2b = i.readByte();
	var a1a = i.readByte();
	var a1b = i.readByte();
	a.a1 = a1a << 8 | a1b;
	a.a2 = a2a << 8 | a2b;
	return a;
};
haxe_crypto_Adler32.prototype = {
	update: function(b,pos,len) {
		var a1 = this.a1;
		var a2 = this.a2;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var p = _g++;
			var c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	,equals: function(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,compare: function(other) {
		var b1 = this.b;
		var b2 = other.b;
		var len = this.length < other.length ? this.length : other.length;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			if(b1[i] != b2[i]) {
				return b1[i] - b2[i];
			}
		}
		return this.length - other.length;
	}
	,getInt32: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	,setInt32: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	,initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g1 = 0;
		var _g2 = this.base.length;
		while(_g1 < _g2) {
			var i1 = _g1++;
			tbl[this.base.b[i1]] = i1;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw new js__$Boot_HaxeError("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,add: function(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			var eof1 = ((eof) instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if(((eof1) instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readUInt16: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_zip_Compress = function() { };
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	throw new js__$Boot_HaxeError("Not implemented for this platform2");
};
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__ : true, __constructs__ : ["Found","NeedBit","NeedBits"]
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_.__params__ = ["n","table"],$_)
};
var haxe_zip_HuffTools = function() {
};
haxe_zip_HuffTools.__name__ = true;
haxe_zip_HuffTools.prototype = {
	treeDepth: function(t) {
		switch(t._hx_index) {
		case 0:
			var _g = t.i;
			return 0;
		case 1:
			var b = t.right;
			var a = t.left;
			var da = this.treeDepth(a);
			var db = this.treeDepth(b);
			return 1 + (da < db ? da : db);
		case 2:
			var _g2 = t.table;
			var _g1 = t.n;
			throw new js__$Boot_HaxeError("assert");
		}
	}
	,treeCompress: function(t) {
		var d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				var b = t.right;
				var a = t.left;
				return haxe_zip_Huffman.NeedBit(this.treeCompress(a),this.treeCompress(b));
			} else {
				throw new js__$Boot_HaxeError("assert");
			}
		}
		var size = 1 << d;
		var table = [];
		var _g = 0;
		var _g1 = size;
		while(_g < _g1) {
			var i = _g++;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	,treeWalk: function(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			var b = t.right;
			var a = t.left;
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,a);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,b);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	,treeMake: function(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw new js__$Boot_HaxeError("Invalid huffman");
		}
		var idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	,make: function(lengths,pos,nlengths,maxbits) {
		var counts = [];
		var tmp = [];
		if(maxbits > 32) {
			throw new js__$Boot_HaxeError("Invalid huffman");
		}
		var _g = 0;
		var _g1 = maxbits;
		while(_g < _g1) {
			var i = _g++;
			counts.push(0);
			tmp.push(0);
		}
		var _g2 = 0;
		var _g3 = nlengths;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var p = lengths[i1 + pos];
			if(p >= maxbits) {
				throw new js__$Boot_HaxeError("Invalid huffman");
			}
			counts[p]++;
		}
		var code = 0;
		var _g4 = 1;
		var _g5 = maxbits - 1;
		while(_g4 < _g5) {
			var i2 = _g4++;
			code = code + counts[i2] << 1;
			tmp[i2] = code;
		}
		var bits = new haxe_ds_IntMap();
		var _g6 = 0;
		var _g7 = nlengths;
		while(_g6 < _g7) {
			var i3 = _g6++;
			var l = lengths[i3 + pos];
			if(l != 0) {
				var n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i3;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
};
var haxe_zip__$InflateImpl_Window = function(hasCrc) {
	this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
	this.pos = 0;
	if(hasCrc) {
		this.crc = new haxe_crypto_Adler32();
	}
};
haxe_zip__$InflateImpl_Window.__name__ = true;
haxe_zip__$InflateImpl_Window.prototype = {
	slide: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		var b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	,addBytes: function(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	,addByte: function(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	,getLastChar: function() {
		return this.buffer.b[this.pos - 1];
	}
	,available: function() {
		return this.pos;
	}
	,checksum: function() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
};
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__ : true, __constructs__ : ["Head","Block","CData","Flat","Crc","Dist","DistOne","Done"]
	,Head: {_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
var haxe_zip_InflateImpl = function(i,header,crc) {
	if(crc == null) {
		crc = true;
	}
	if(header == null) {
		header = true;
	}
	this.isFinal = false;
	this.htools = new haxe_zip_HuffTools();
	this.huffman = this.buildFixedHuffman();
	this.huffdist = null;
	this.len = 0;
	this.dist = 0;
	this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
	this.input = i;
	this.bits = 0;
	this.nbits = 0;
	this.needed = 0;
	this.output = null;
	this.outpos = 0;
	this.lengths = [];
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.lengths.push(-1);
	this.window = new haxe_zip__$InflateImpl_Window(crc);
};
haxe_zip_InflateImpl.__name__ = true;
haxe_zip_InflateImpl.run = function(i,bufsize) {
	if(bufsize == null) {
		bufsize = 65536;
	}
	var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
	var output = new haxe_io_BytesBuffer();
	var inflate = new haxe_zip_InflateImpl(i);
	while(true) {
		var len = inflate.readBytes(buf,0,bufsize);
		output.addBytes(buf,0,len);
		if(len < bufsize) {
			break;
		}
	}
	return output.getBytes();
};
haxe_zip_InflateImpl.prototype = {
	buildFixedHuffman: function() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		var a = [];
		var _g = 0;
		while(_g < 288) {
			var n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	,readBytes: function(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	,getBits: function(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		var b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	,getBit: function() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		var b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	,getRevBits: function(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	,resetBits: function() {
		this.bits = 0;
		this.nbits = 0;
	}
	,addBytes: function(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	,addByte: function(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	,addDistOne: function(n) {
		var c = this.window.getLastChar();
		var _g = 0;
		var _g1 = n;
		while(_g < _g1) {
			var i = _g++;
			this.addByte(c);
		}
	}
	,addDist: function(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	,applyHuffman: function(h) {
		switch(h._hx_index) {
		case 0:
			var n = h.i;
			return n;
		case 1:
			var b = h.right;
			var a = h.left;
			return this.applyHuffman(this.getBit() ? b : a);
		case 2:
			var tbl = h.table;
			var n1 = h.n;
			return this.applyHuffman(tbl[this.getBits(n1)]);
		}
	}
	,inflateLengths: function(a,max) {
		var i = 0;
		var prev = 0;
		while(i < max) {
			var n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				var end = i + 3 + this.getBits(2);
				if(end > max) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid data");
			}
		}
	}
	,inflateLoop: function() {
		switch(this.state._hx_index) {
		case 0:
			var cmf = this.input.readByte();
			var cm = cmf & 15;
			var cinfo = cmf >> 4;
			if(cm != 8) {
				throw new js__$Boot_HaxeError("Invalid data");
			}
			var flg = this.input.readByte();
			var fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw new js__$Boot_HaxeError("Invalid data");
			}
			if(fdict) {
				throw new js__$Boot_HaxeError("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				var nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				var r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				var hlit = this.getBits(5) + 257;
				var hdist = this.getBits(5) + 1;
				var hclen = this.getBits(4) + 4;
				var _g = 0;
				var _g1 = hclen;
				while(_g < _g1) {
					var i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				var _g2 = hclen;
				var _g3 = 19;
				while(_g2 < _g3) {
					var i1 = _g2++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i1]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				var lengths = [];
				var _g4 = 0;
				var _g5 = hlit + hdist;
				while(_g4 < _g5) {
					var i2 = _g4++;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw new js__$Boot_HaxeError("Invalid data");
			}
			break;
		case 2:
			var n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				var extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				var dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw new js__$Boot_HaxeError("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			var rlen = this.len < this.needed ? this.len : this.needed;
			var bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			var calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			var crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw new js__$Boot_HaxeError("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				var rdist = this.len < this.dist ? this.len : this.dist;
				var rlen1 = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen1);
				this.len -= rlen1;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			var rlen2 = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen2);
			this.len -= rlen2;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
};
var haxe_zip_Uncompress = function() { };
haxe_zip_Uncompress.__name__ = true;
haxe_zip_Uncompress.run = function(src,bufsize) {
	return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
haxe_Resource.content = [{ name : "AffineTransformation", data : "cGFja2FnZSBleGFtcGxlczsKCmltcG9ydCBleGFtcGxlcy5FeGFtcGxlOwppbXBvcnQgYml0bWFwLio7CmltcG9ydCBiaXRtYXAuVHlwZXMuQmFja2dyb3VuZDsKaW1wb3J0IGJpdG1hcC50cmFuc2Zvcm1hdGlvbi5BZmZpbmU7CmltcG9ydCBqcy5odG1sLkltYWdlRWxlbWVudDsKCmNsYXNzIEFmZmluZVRyYW5zZm9ybWF0aW9uIGltcGxlbWVudHMgRXhhbXBsZSB7CglwdWJsaWMgZnVuY3Rpb24gbmV3KCkge30KCglwdWJsaWMgZnVuY3Rpb24gcnVuKGJpdG1hcDpCaXRtYXAsIG91dHB1dHM6QXJyYXk8anMuaHRtbC5JbWFnZUVsZW1lbnQ+KSB7CgkJLy8ganVzdCBzY2FsZSwgYnV0IHdlIHdhbnQgdG8gc2V0IHRoZSBiZyBwcm9wZXJ0eSBvbiB0aGUgYml0bWFwIGZpcnN0IHNvIHBhZGRpbmcgaXMgdHJhbnNwYXJlbnQKCQliaXRtYXAuYmcgPSBDb2xvci5jcmVhdGUoMjU1LCAwLCAwLCAyMjIpOwoJCXZhciByZXN1bHQxID0gYml0bWFwLnRyYW5zZm9ybS5hZmZpbmUoewoJCQlhZmZpbmU6IG5ldyBBZmZpbmUoKS5zY2FsZSgwLjcsIDAuNiksCgkJCWJnOiBCYWNrZ3JvdW5kLmJnCgkJfSk7CgkJb3V0cHV0c1sxXS5zcmMgPSByZXN1bHQxLmJpdG1hcC5pby50b0RhdGFVcmwoKTsKCgkJLy8gY29tcG9zZSB0cmFuc2Zvcm1hdGlvbnMgdXNpbmcgdGhlIG1hdHJpeAoJCXZhciByZXN1bHQyID0gYml0bWFwLnRyYW5zZm9ybS5hZmZpbmUoewoJCQlhZmZpbmU6IG5ldyBBZmZpbmUoKS5zY2FsZSgwLjUsIDAuMykudHJhbnNsYXRlKDIyMiwgMjExKS5yb3RhdGVEZWcoMzUuNiksCgkJfSk7CgkJb3V0cHV0c1syXS5zcmMgPSByZXN1bHQyLmJpdG1hcC5pby50b0RhdGFVcmwoKTsKCgkJLy8gbWFudWFsbHkgZGVmaW5lIHRoZSBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4CgkJdmFyIHJlc3VsdDMgPSBiaXRtYXAudHJhbnNmb3JtLmFmZmluZSh7CgkJCW1hdHJpeDogewoJCQkJYTogMC40LAoJCQkJYjogMC41LAoJCQkJYzogMC4yLAoJCQkJZDogMS41LAoJCQkJZTogMi4wLAoJCQkJZjogMy4wCgkJCX0KCQl9KTsKCQlvdXRwdXRzWzNdLnNyYyA9IHJlc3VsdDMuYml0bWFwLmlvLnRvRGF0YVVybCgpOwoJfQoKCXB1YmxpYyBmdW5jdGlvbiBnZXRTb3VyY2UoKSB7CgkJcmV0dXJuIGhheGUuUmVzb3VyY2UuZ2V0U3RyaW5nKCJBZmZpbmVUcmFuc2Zvcm1hdGlvbiIpOwoJfQp9Cg"},{ name : "Colors", data : "cGFja2FnZSBleGFtcGxlczsKCmltcG9ydCBleGFtcGxlcy5FeGFtcGxlOwppbXBvcnQgYml0bWFwLkJpdG1hcDsKaW1wb3J0IGJpdG1hcC50cmFuc2Zvcm1hdGlvbi5Db252b2x1dGlvbjsKaW1wb3J0IGpzLmh0bWwuSW1hZ2VFbGVtZW50OwoKY2xhc3MgQ29sb3JzIGltcGxlbWVudHMgRXhhbXBsZSB7CglwdWJsaWMgZnVuY3Rpb24gbmV3KCkge30KCglwdWJsaWMgZnVuY3Rpb24gcnVuKGJpdG1hcDpCaXRtYXAsIG91dHB1dHM6QXJyYXk8anMuaHRtbC5JbWFnZUVsZW1lbnQ+KSB7CgkJdmFyIHJlc3VsdDAgPSBiaXRtYXAuY29sb3IuZmlsdGVyKHsKCQkJYWxwaGE6IHthOiAwLjIsIGM6IDB9CgkJfSk7CgkJb3V0cHV0c1swXS5zcmMgPSByZXN1bHQwLmlvLnRvRGF0YVVybCgpOwoKCQl2YXIgcmVzdWx0MSA9IGJpdG1hcC5jb2xvci5maWx0ZXIoewoJCQlyZWQ6IHthOiAxLjUsIGM6IDJ9LAoJCQlncmVlbjoge2E6IDEuMCwgYzogLTE1fSwKCQkJYWxwaGE6IHthOiAwLjYsIGM6IDB9CgkJfSk7CgkJb3V0cHV0c1sxXS5zcmMgPSByZXN1bHQxLmlvLnRvRGF0YVVybCgpOwoJfQoKCXB1YmxpYyBmdW5jdGlvbiBnZXRTb3VyY2UoKSB7CgkJcmV0dXJuIGhheGUuUmVzb3VyY2UuZ2V0U3RyaW5nKCJDb2xvcnMiKTsKCX0KfQo"},{ name : "Convolutions", data : "cGFja2FnZSBleGFtcGxlczsKCmltcG9ydCBleGFtcGxlcy5FeGFtcGxlOwppbXBvcnQgYml0bWFwLkJpdG1hcDsKaW1wb3J0IGJpdG1hcC50cmFuc2Zvcm1hdGlvbi5Db252b2x1dGlvbjsKaW1wb3J0IGpzLmh0bWwuSW1hZ2VFbGVtZW50OwoKY2xhc3MgQ29udm9sdXRpb25zIGltcGxlbWVudHMgRXhhbXBsZSB7CglwdWJsaWMgZnVuY3Rpb24gbmV3KCkge30KCglwdWJsaWMgZnVuY3Rpb24gcnVuKGJpdG1hcDpCaXRtYXAsIG91dHB1dHM6QXJyYXk8anMuaHRtbC5JbWFnZUVsZW1lbnQ+KSB7CiAgICAvLyBzaG9ydGN1dCB0byBibHVyIGNvbnZvbHV0aW9uCgkJdmFyIHJlc3VsdDAgPSBiaXRtYXAudHJhbnNmb3JtLmNvbnZvbHZlKENvbnZvbHV0aW9uLmJsdXIoNykpOwoJCW91dHB1dHNbMF0uc3JjID0gcmVzdWx0MC5pby50b0RhdGFVcmwoKTsKCgkJdmFyIHJlc3VsdDEgPSBiaXRtYXAudHJhbnNmb3JtLmNvbnZvbHZlKENvbnZvbHV0aW9uLnNoYXJwKDAuNywgMC4xKSk7CgkJb3V0cHV0c1sxXS5zcmMgPSByZXN1bHQxLmlvLnRvRGF0YVVybCgpOwogICAgCiAgICAvLyBkZWZpbmluZyB0aGUga2VybmVsIG1hbnVhbGx5CgkJdmFyIGVkZ3kgPSBbWzAuMCwgLTEuMCwgMC4wXSwgWy0xLjAsIDQuMCwgLTEuMF0sIFswLjAsIC0xLjAsIDAuMF1dOwoJCXZhciByZXN1bHQzID0gYml0bWFwLnRyYW5zZm9ybS5jb252b2x2ZSh7CgkJCWtlcm5lbDogZWRneSwKCQkJYmlhczogMC4yLAoJCQlmYWN0b3I6IDEuMSwKCQl9KTsKCQlvdXRwdXRzWzNdLnNyYyA9IHJlc3VsdDMuaW8udG9EYXRhVXJsKCk7Cgl9CiAgICAgcHVibGljIGZ1bmN0aW9uIGdldFNvdXJjZSgpIHsKICAgICByZXR1cm4gIGhheGUuUmVzb3VyY2UuZ2V0U3RyaW5nKCJDb252b2x1dGlvbnMiKTsKICAgfQp9Cg"},{ name : "Shapes", data : "cGFja2FnZSBleGFtcGxlczsKaW1wb3J0IGV4YW1wbGVzLkV4YW1wbGU7CgppbXBvcnQgYml0bWFwLlR5cGVzLkJsZW5kOwppbXBvcnQgYml0bWFwLio7CmltcG9ydCBqcy5odG1sLio7CgpjbGFzcyBTaGFwZXMgaW1wbGVtZW50cyBFeGFtcGxlIHsKICBwdWJsaWMgZnVuY3Rpb24gbmV3KCl7fQogIHB1YmxpYyBmdW5jdGlvbiBydW4oYml0bWFwIDogQml0bWFwLCBvdXRwdXRzOkFycmF5PGpzLmh0bWwuSW1hZ2VFbGVtZW50Pil7CiAgICBiaXRtYXAuZHJhdy5yZWN0YW5nbGUyKDIwLCA0MCwgMTAwLCA1MCwgQ29sb3IuY3JlYXRlKDIyMSwgMTExLCAxMTEsIDY2KSwgdHJ1ZSwge3R5cGU6IEJsZW5kLm1lYW59KTsKCQliaXRtYXAuZHJhdy50cmlhbmdsZSgyMjAsIDMwLCAzMDAsIDE1MCwgOTAsIDIxMCwgQ29sb3IuY3JlYXRlKDIxLCAyMTEsIDExMSwgNjYpLCB0cnVlLCB7dHlwZTogQmxlbmQubWVhbn0pOwoJCWJpdG1hcC5kcmF3LmxpbmUoMTIgLCAyMTEsIDg4LCAxLCBDb2xvci5jcmVhdGUoMjEsIDIxLCAyMTEsIDE2NikpOwoJCW91dHB1dHNbMF0uc3JjID0gYml0bWFwLmlvLnRvRGF0YVVybCgpOwoKICAgfQogICBwdWJsaWMgZnVuY3Rpb24gZ2V0U291cmNlKCkgewogICAgIHJldHVybiAgaGF4ZS5SZXNvdXJjZS5nZXRTdHJpbmcoIlNoYXBlcyIpOwogICB9Cn0"},{ name : "Pixelize", data : "cGFja2FnZSBleGFtcGxlczsKCmltcG9ydCBleGFtcGxlcy5FeGFtcGxlOwppbXBvcnQgYml0bWFwLkJpdG1hcDsKaW1wb3J0IGJpdG1hcC50cmFuc2Zvcm1hdGlvbi5Db252b2x1dGlvbjsKaW1wb3J0IGpzLmh0bWwuSW1hZ2VFbGVtZW50OwoKY2xhc3MgUGl4ZWxpemUgaW1wbGVtZW50cyBFeGFtcGxlIHsKCXB1YmxpYyBmdW5jdGlvbiBuZXcoKSB7fQoKCXB1YmxpYyBmdW5jdGlvbiBydW4oYml0bWFwOkJpdG1hcCwgb3V0cHV0czpBcnJheTxqcy5odG1sLkltYWdlRWxlbWVudD4pIHsKCQl2YXIgcmVzdWx0MCA9IGJpdG1hcC50cmFuc2Zvcm0ucGl4ZWxpemUoe3dpZHRoOiAxMDAsIGhlaWdodDogOTB9KTsKCQlvdXRwdXRzWzBdLnNyYyA9IHJlc3VsdDAuaW8udG9EYXRhVXJsKCk7CgkJb3V0cHV0c1sxXS5zcmMgPSBiaXRtYXAudHJhbnNmb3JtLnBpeGVsaXplKHt3aWR0aDogNzAsIGhlaWdodDogNjB9KS5pby50b0RhdGFVcmwoKTsKCQlvdXRwdXRzWzJdLnNyYyA9IGJpdG1hcC50cmFuc2Zvcm0ucGl4ZWxpemUoe3dpZHRoOiA0MCwgaGVpZ2h0OiAzNH0pLmlvLnRvRGF0YVVybCgpOwoJCW91dHB1dHNbM10uc3JjID0gYml0bWFwLnRyYW5zZm9ybS5waXhlbGl6ZSh7d2lkdGg6IDI4LCBoZWlnaHQ6IDI1fSkuaW8udG9EYXRhVXJsKCk7CgkJb3V0cHV0c1s0XS5zcmMgPSBiaXRtYXAudHJhbnNmb3JtLnBpeGVsaXplKHt3aWR0aDogMTksIGhlaWdodDogMTV9KS5pby50b0RhdGFVcmwoKTsKCX0KICAgcHVibGljIGZ1bmN0aW9uIGdldFNvdXJjZSgpIHsKICAgICByZXR1cm4gIGhheGUuUmVzb3VyY2UuZ2V0U3RyaW5nKCJQaXhlbGl6ZSIpOwogICB9Cn0K"}];
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
bitmap_support_Pako.js = "\n/* pako 1.0.4 nodeca/pako */\n!function(t){(typeof global==='undefined' ? window : global).pako=t()}(function(){return function t(e,a,i){function n(s,o){if(!a[s]){if(!e[s]){var l=\"function\"==typeof require&&require;if(!o&&l)return l(s,!0);if(r)return r(s,!0);var h=new Error(\"Cannot find module '\"+s+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var d=a[s]={exports:{}};e[s][0].call(d.exports,function(t){var a=e[s][1][t];return n(a?a:t)},d,d.exports,t,e,a,i)}return a[s].exports}for(var r=\"function\"==typeof require&&require,s=0;s<i.length;s++)n(i[s]);return n}({1:[function(t,e,a){\"use strict\";function i(t){if(!(this instanceof i))return new i(t);this.options=l.assign({level:w,method:v,chunkSize:16384,windowBits:15,memLevel:8,strategy:p,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=o.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==b)throw new Error(d[a]);if(e.header&&o.deflateSetHeader(this.strm,e.header),e.dictionary){var n;if(n=\"string\"==typeof e.dictionary?h.string2buf(e.dictionary):\"[object ArrayBuffer]\"===_.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=o.deflateSetDictionary(this.strm,n),a!==b)throw new Error(d[a]);this._dict_set=!0}}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}function s(t,e){return e=e||{},e.gzip=!0,n(t,e)}var o=t(\"./zlib/deflate\"),l=t(\"./utils/common\"),h=t(\"./utils/strings\"),d=t(\"./zlib/messages\"),f=t(\"./zlib/zstream\"),_=Object.prototype.toString,u=0,c=4,b=0,g=1,m=2,w=-1,p=0,v=8;i.prototype.push=function(t,e){var a,i,n=this.strm,r=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:e===!0?c:u,\"string\"==typeof t?n.input=h.string2buf(t):\"[object ArrayBuffer]\"===_.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new l.Buf8(r),n.next_out=0,n.avail_out=r),a=o.deflate(n,i),a!==g&&a!==b)return this.onEnd(a),this.ended=!0,!1;0!==n.avail_out&&(0!==n.avail_in||i!==c&&i!==m)||(\"string\"===this.options.to?this.onData(h.buf2binstring(l.shrinkBuf(n.output,n.next_out))):this.onData(l.shrinkBuf(n.output,n.next_out)))}while((n.avail_in>0||0===n.avail_out)&&a!==g);return i===c?(a=o.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===b):i!==m||(this.onEnd(b),n.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===b&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=l.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Deflate=i,a.deflate=n,a.deflateRaw=r,a.gzip=s},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/deflate\":8,\"./zlib/messages\":13,\"./zlib/zstream\":15}],2:[function(t,e,a){\"use strict\";function i(t){if(!(this instanceof i))return new i(t);this.options=o.assign({chunkSize:16384,windowBits:0,to:\"\"},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0===(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=s.inflateInit2(this.strm,e.windowBits);if(a!==h.Z_OK)throw new Error(d[a]);this.header=new _,s.inflateGetHeader(this.strm,this.header)}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}var s=t(\"./zlib/inflate\"),o=t(\"./utils/common\"),l=t(\"./utils/strings\"),h=t(\"./zlib/constants\"),d=t(\"./zlib/messages\"),f=t(\"./zlib/zstream\"),_=t(\"./zlib/gzheader\"),u=Object.prototype.toString;i.prototype.push=function(t,e){var a,i,n,r,d,f,_=this.strm,c=this.options.chunkSize,b=this.options.dictionary,g=!1;if(this.ended)return!1;i=e===~~e?e:e===!0?h.Z_FINISH:h.Z_NO_FLUSH,\"string\"==typeof t?_.input=l.binstring2buf(t):\"[object ArrayBuffer]\"===u.call(t)?_.input=new Uint8Array(t):_.input=t,_.next_in=0,_.avail_in=_.input.length;do{if(0===_.avail_out&&(_.output=new o.Buf8(c),_.next_out=0,_.avail_out=c),a=s.inflate(_,h.Z_NO_FLUSH),a===h.Z_NEED_DICT&&b&&(f=\"string\"==typeof b?l.string2buf(b):\"[object ArrayBuffer]\"===u.call(b)?new Uint8Array(b):b,a=s.inflateSetDictionary(this.strm,f)),a===h.Z_BUF_ERROR&&g===!0&&(a=h.Z_OK,g=!1),a!==h.Z_STREAM_END&&a!==h.Z_OK)return this.onEnd(a),this.ended=!0,!1;_.next_out&&(0!==_.avail_out&&a!==h.Z_STREAM_END&&(0!==_.avail_in||i!==h.Z_FINISH&&i!==h.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(n=l.utf8border(_.output,_.next_out),r=_.next_out-n,d=l.buf2string(_.output,n),_.next_out=r,_.avail_out=c-r,r&&o.arraySet(_.output,_.output,n,r,0),this.onData(d)):this.onData(o.shrinkBuf(_.output,_.next_out)))),0===_.avail_in&&0===_.avail_out&&(g=!0)}while((_.avail_in>0||0===_.avail_out)&&a!==h.Z_STREAM_END);return a===h.Z_STREAM_END&&(i=h.Z_FINISH),i===h.Z_FINISH?(a=s.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===h.Z_OK):i!==h.Z_SYNC_FLUSH||(this.onEnd(h.Z_OK),_.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===h.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Inflate=i,a.inflate=n,a.inflateRaw=r,a.ungzip=n},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/constants\":6,\"./zlib/gzheader\":9,\"./zlib/inflate\":11,\"./zlib/messages\":13,\"./zlib/zstream\":15}],3:[function(t,e,a){\"use strict\";var i=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;a.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var a=e.shift();if(a){if(\"object\"!=typeof a)throw new TypeError(a+\"must be non-object\");for(var i in a)a.hasOwnProperty(i)&&(t[i]=a[i])}}return t},a.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,a,i,n){if(e.subarray&&t.subarray)return void t.set(e.subarray(a,a+i),n);for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){var e,a,i,n,r,s;for(i=0,e=0,a=t.length;e<a;e++)i+=t[e].length;for(s=new Uint8Array(i),n=0,e=0,a=t.length;e<a;e++)r=t[e],s.set(r,n),n+=r.length;return s}},r={arraySet:function(t,e,a,i,n){for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){return[].concat.apply([],t)}};a.setTyped=function(t){t?(a.Buf8=Uint8Array,a.Buf16=Uint16Array,a.Buf32=Int32Array,a.assign(a,n)):(a.Buf8=Array,a.Buf16=Array,a.Buf32=Array,a.assign(a,r))},a.setTyped(i)},{}],4:[function(t,e,a){\"use strict\";function i(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&r))return String.fromCharCode.apply(null,n.shrinkBuf(t,e));for(var a=\"\",i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a}var n=t(\"./common\"),r=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){r=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var o=new n.Buf8(256),l=0;l<256;l++)o[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1;o[254]=o[254]=1,a.string2buf=function(t){var e,a,i,r,s,o=t.length,l=0;for(r=0;r<o;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),l+=a<128?1:a<2048?2:a<65536?3:4;for(e=new n.Buf8(l),s=0,r=0;s<l;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},a.buf2binstring=function(t){return i(t,t.length)},a.binstring2buf=function(t){for(var e=new n.Buf8(t.length),a=0,i=e.length;a<i;a++)e[a]=t.charCodeAt(a);return e},a.buf2string=function(t,e){var a,n,r,s,l=e||t.length,h=new Array(2*l);for(n=0,a=0;a<l;)if(r=t[a++],r<128)h[n++]=r;else if(s=o[r],s>4)h[n++]=65533,a+=s-1;else{for(r&=2===s?31:3===s?15:7;s>1&&a<l;)r=r<<6|63&t[a++],s--;s>1?h[n++]=65533:r<65536?h[n++]=r:(r-=65536,h[n++]=55296|r>>10&1023,h[n++]=56320|1023&r)}return i(h,n)},a.utf8border=function(t,e){var a;for(e=e||t.length,e>t.length&&(e=t.length),a=e-1;a>=0&&128===(192&t[a]);)a--;return a<0?e:0===a?e:a+o[t[a]]>e?a:e}},{\"./common\":3}],5:[function(t,e,a){\"use strict\";function i(t,e,a,i){for(var n=65535&t|0,r=t>>>16&65535|0,s=0;0!==a;){s=a>2e3?2e3:a,a-=s;do n=n+e[i++]|0,r=r+n|0;while(--s);n%=65521,r%=65521}return n|r<<16|0}e.exports=i},{}],6:[function(t,e,a){\"use strict\";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],7:[function(t,e,a){\"use strict\";function i(){for(var t,e=[],a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}function n(t,e,a,i){var n=r,s=i+a;t^=-1;for(var o=i;o<s;o++)t=t>>>8^n[255&(t^e[o])];return t^-1}var r=i();e.exports=n},{}],8:[function(t,e,a){\"use strict\";function i(t,e){return t.msg=D[e],e}function n(t){return(t<<1)-(t>4?9:0)}function r(t){for(var e=t.length;--e>=0;)t[e]=0}function s(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(R.arraySet(t.output,e.pending_buf,e.pending_out,a,t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))}function o(t,e){C._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,s(t.strm)}function l(t,e){t.pending_buf[t.pending++]=e}function h(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function d(t,e,a,i){var n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,R.arraySet(e,t.input,t.next_in,n,a),1===t.state.wrap?t.adler=N(t.adler,e,n,a):2===t.state.wrap&&(t.adler=O(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)}function f(t,e){var a,i,n=t.max_chain_length,r=t.strstart,s=t.prev_length,o=t.nice_match,l=t.strstart>t.w_size-ft?t.strstart-(t.w_size-ft):0,h=t.window,d=t.w_mask,f=t.prev,_=t.strstart+dt,u=h[r+s-1],c=h[r+s];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do if(a=e,h[a+s]===c&&h[a+s-1]===u&&h[a]===h[r]&&h[++a]===h[r+1]){r+=2,a++;do;while(h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&r<_);if(i=dt-(_-r),r=_-dt,i>s){if(t.match_start=e,s=i,i>=o)break;u=h[r+s-1],c=h[r+s]}}while((e=f[e&d])>l&&0!==--n);return s<=t.lookahead?s:t.lookahead}function _(t){var e,a,i,n,r,s=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=s+(s-ft)){R.arraySet(t.window,t.window,s,s,0),t.match_start-=s,t.strstart-=s,t.block_start-=s,a=t.hash_size,e=a;do i=t.head[--e],t.head[e]=i>=s?i-s:0;while(--a);a=s,e=a;do i=t.prev[--e],t.prev[e]=i>=s?i-s:0;while(--a);n+=s}if(0===t.strm.avail_in)break;if(a=d(t.strm,t.window,t.strstart+t.lookahead,n),t.lookahead+=a,t.lookahead+t.insert>=ht)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+ht-1])&t.hash_mask,t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<ht)););}while(t.lookahead<ft&&0!==t.strm.avail_in)}function u(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(_(t),0===t.lookahead&&e===I)return vt;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+a;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,o(t,!1),0===t.strm.avail_out))return vt;if(t.strstart-t.block_start>=t.w_size-ft&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.strstart>t.block_start&&(o(t,!1),0===t.strm.avail_out)?vt:vt}function c(t,e){for(var a,i;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a)),t.match_length>=ht)if(i=C._tr_tally(t,t.strstart-t.match_start,t.match_length-ht),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=ht){t.match_length--;do t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(0!==--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function b(t,e){for(var a,i,n;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=ht-1,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a),t.match_length<=5&&(t.strategy===q||t.match_length===ht&&t.strstart-t.match_start>4096)&&(t.match_length=ht-1)),t.prev_length>=ht&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-ht,i=C._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-ht),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(0!==--t.prev_length);if(t.match_available=0,t.match_length=ht-1,t.strstart++,i&&(o(t,!1),0===t.strm.avail_out))return vt}else if(t.match_available){if(i=C._tr_tally(t,0,t.window[t.strstart-1]),i&&o(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return vt}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=C._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function g(t,e){for(var a,i,n,r,s=t.window;;){if(t.lookahead<=dt){if(_(t),t.lookahead<=dt&&e===I)return vt;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=ht&&t.strstart>0&&(n=t.strstart-1,i=s[n],i===s[++n]&&i===s[++n]&&i===s[++n])){r=t.strstart+dt;do;while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<r);t.match_length=dt-(r-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=ht?(a=C._tr_tally(t,1,t.match_length-ht),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function m(t,e){for(var a;;){if(0===t.lookahead&&(_(t),0===t.lookahead)){if(e===I)return vt;break}if(t.match_length=0,a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function w(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}function p(t){t.window_size=2*t.w_size,r(t.head),t.max_lazy_match=Z[t.level].max_lazy,t.good_match=Z[t.level].good_length,t.nice_match=Z[t.level].nice_length,t.max_chain_length=Z[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=ht-1,t.match_available=0,t.ins_h=0}function v(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=V,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new R.Buf16(2*ot),this.dyn_dtree=new R.Buf16(2*(2*rt+1)),this.bl_tree=new R.Buf16(2*(2*st+1)),r(this.dyn_ltree),r(this.dyn_dtree),r(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new R.Buf16(lt+1),this.heap=new R.Buf16(2*nt+1),r(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new R.Buf16(2*nt+1),r(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function k(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=Q,e=t.state,e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?ut:wt,t.adler=2===e.wrap?0:1,e.last_flush=I,C._tr_init(e),H):i(t,K)}function y(t){var e=k(t);return e===H&&p(t.state),e}function x(t,e){return t&&t.state?2!==t.state.wrap?K:(t.state.gzhead=e,H):K}function z(t,e,a,n,r,s){if(!t)return K;var o=1;if(e===Y&&(e=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),r<1||r>$||a!==V||n<8||n>15||e<0||e>9||s<0||s>W)return i(t,K);8===n&&(n=9);var l=new v;return t.state=l,l.strm=t,l.wrap=o,l.gzhead=null,l.w_bits=n,l.w_size=1<<l.w_bits,l.w_mask=l.w_size-1,l.hash_bits=r+7,l.hash_size=1<<l.hash_bits,l.hash_mask=l.hash_size-1,l.hash_shift=~~((l.hash_bits+ht-1)/ht),l.window=new R.Buf8(2*l.w_size),l.head=new R.Buf16(l.hash_size),l.prev=new R.Buf16(l.w_size),l.lit_bufsize=1<<r+6,l.pending_buf_size=4*l.lit_bufsize,l.pending_buf=new R.Buf8(l.pending_buf_size),l.d_buf=1*l.lit_bufsize,l.l_buf=3*l.lit_bufsize,l.level=e,l.strategy=s,l.method=a,y(t)}function B(t,e){return z(t,e,V,tt,et,J)}function S(t,e){var a,o,d,f;if(!t||!t.state||e>L||e<0)return t?i(t,K):K;if(o=t.state,!t.output||!t.input&&0!==t.avail_in||o.status===pt&&e!==F)return i(t,0===t.avail_out?P:K);if(o.strm=t,a=o.last_flush,o.last_flush=e,o.status===ut)if(2===o.wrap)t.adler=0,l(o,31),l(o,139),l(o,8),o.gzhead?(l(o,(o.gzhead.text?1:0)+(o.gzhead.hcrc?2:0)+(o.gzhead.extra?4:0)+(o.gzhead.name?8:0)+(o.gzhead.comment?16:0)),l(o,255&o.gzhead.time),l(o,o.gzhead.time>>8&255),l(o,o.gzhead.time>>16&255),l(o,o.gzhead.time>>24&255),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,255&o.gzhead.os),o.gzhead.extra&&o.gzhead.extra.length&&(l(o,255&o.gzhead.extra.length),l(o,o.gzhead.extra.length>>8&255)),o.gzhead.hcrc&&(t.adler=O(t.adler,o.pending_buf,o.pending,0)),o.gzindex=0,o.status=ct):(l(o,0),l(o,0),l(o,0),l(o,0),l(o,0),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,zt),o.status=wt);else{var _=V+(o.w_bits-8<<4)<<8,u=-1;u=o.strategy>=G||o.level<2?0:o.level<6?1:6===o.level?2:3,_|=u<<6,0!==o.strstart&&(_|=_t),_+=31-_%31,o.status=wt,h(o,_),0!==o.strstart&&(h(o,t.adler>>>16),h(o,65535&t.adler)),t.adler=1}if(o.status===ct)if(o.gzhead.extra){for(d=o.pending;o.gzindex<(65535&o.gzhead.extra.length)&&(o.pending!==o.pending_buf_size||(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending!==o.pending_buf_size));)l(o,255&o.gzhead.extra[o.gzindex]),o.gzindex++;o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),o.gzindex===o.gzhead.extra.length&&(o.gzindex=0,o.status=bt)}else o.status=bt;if(o.status===bt)if(o.gzhead.name){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.name.length?255&o.gzhead.name.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.gzindex=0,o.status=gt)}else o.status=gt;if(o.status===gt)if(o.gzhead.comment){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.comment.length?255&o.gzhead.comment.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.status=mt)}else o.status=mt;if(o.status===mt&&(o.gzhead.hcrc?(o.pending+2>o.pending_buf_size&&s(t),o.pending+2<=o.pending_buf_size&&(l(o,255&t.adler),l(o,t.adler>>8&255),t.adler=0,o.status=wt)):o.status=wt),0!==o.pending){if(s(t),0===t.avail_out)return o.last_flush=-1,H}else if(0===t.avail_in&&n(e)<=n(a)&&e!==F)return i(t,P);if(o.status===pt&&0!==t.avail_in)return i(t,P);if(0!==t.avail_in||0!==o.lookahead||e!==I&&o.status!==pt){var c=o.strategy===G?m(o,e):o.strategy===X?g(o,e):Z[o.level].func(o,e);if(c!==yt&&c!==xt||(o.status=pt),c===vt||c===yt)return 0===t.avail_out&&(o.last_flush=-1),H;if(c===kt&&(e===U?C._tr_align(o):e!==L&&(C._tr_stored_block(o,0,0,!1),e===T&&(r(o.head),0===o.lookahead&&(o.strstart=0,o.block_start=0,o.insert=0))),s(t),0===t.avail_out))return o.last_flush=-1,H}return e!==F?H:o.wrap<=0?j:(2===o.wrap?(l(o,255&t.adler),l(o,t.adler>>8&255),l(o,t.adler>>16&255),l(o,t.adler>>24&255),l(o,255&t.total_in),l(o,t.total_in>>8&255),l(o,t.total_in>>16&255),l(o,t.total_in>>24&255)):(h(o,t.adler>>>16),h(o,65535&t.adler)),s(t),o.wrap>0&&(o.wrap=-o.wrap),0!==o.pending?H:j)}function E(t){var e;return t&&t.state?(e=t.state.status,e!==ut&&e!==ct&&e!==bt&&e!==gt&&e!==mt&&e!==wt&&e!==pt?i(t,K):(t.state=null,e===wt?i(t,M):H)):K}function A(t,e){var a,i,n,s,o,l,h,d,f=e.length;if(!t||!t.state)return K;if(a=t.state,s=a.wrap,2===s||1===s&&a.status!==ut||a.lookahead)return K;for(1===s&&(t.adler=N(t.adler,e,f,0)),a.wrap=0,f>=a.w_size&&(0===s&&(r(a.head),a.strstart=0,a.block_start=0,a.insert=0),d=new R.Buf8(a.w_size),R.arraySet(d,e,f-a.w_size,a.w_size,0),e=d,f=a.w_size),o=t.avail_in,l=t.next_in,h=t.input,t.avail_in=f,t.next_in=0,t.input=e,_(a);a.lookahead>=ht;){i=a.strstart,n=a.lookahead-(ht-1);do a.ins_h=(a.ins_h<<a.hash_shift^a.window[i+ht-1])&a.hash_mask,a.prev[i&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=i,i++;while(--n);a.strstart=i,a.lookahead=ht-1,_(a)}return a.strstart+=a.lookahead,a.block_start=a.strstart,a.insert=a.lookahead,a.lookahead=0,a.match_length=a.prev_length=ht-1,a.match_available=0,t.next_in=l,t.input=h,t.avail_in=o,a.wrap=s,H}var Z,R=t(\"../utils/common\"),C=t(\"./trees\"),N=t(\"./adler32\"),O=t(\"./crc32\"),D=t(\"./messages\"),I=0,U=1,T=3,F=4,L=5,H=0,j=1,K=-2,M=-3,P=-5,Y=-1,q=1,G=2,X=3,W=4,J=0,Q=2,V=8,$=9,tt=15,et=8,at=29,it=256,nt=it+1+at,rt=30,st=19,ot=2*nt+1,lt=15,ht=3,dt=258,ft=dt+ht+1,_t=32,ut=42,ct=69,bt=73,gt=91,mt=103,wt=113,pt=666,vt=1,kt=2,yt=3,xt=4,zt=3;Z=[new w(0,0,0,0,u),new w(4,4,8,4,c),new w(4,5,16,8,c),new w(4,6,32,32,c),new w(4,4,16,16,b),new w(8,16,32,32,b),new w(8,16,128,128,b),new w(8,32,128,256,b),new w(32,128,258,1024,b),new w(32,258,258,4096,b)],a.deflateInit=B,a.deflateInit2=z,a.deflateReset=y,a.deflateResetKeep=k,a.deflateSetHeader=x,a.deflate=S,a.deflateEnd=E,a.deflateSetDictionary=A,a.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./messages\":13,\"./trees\":14}],9:[function(t,e,a){\"use strict\";function i(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}e.exports=i},{}],10:[function(t,e,a){\"use strict\";var i=30,n=12;e.exports=function(t,e){var a,r,s,o,l,h,d,f,_,u,c,b,g,m,w,p,v,k,y,x,z,B,S,E,A;a=t.state,r=t.next_in,E=t.input,s=r+(t.avail_in-5),o=t.next_out,A=t.output,l=o-(e-t.avail_out),h=o+(t.avail_out-257),d=a.dmax,f=a.wsize,_=a.whave,u=a.wnext,c=a.window,b=a.hold,g=a.bits,m=a.lencode,w=a.distcode,p=(1<<a.lenbits)-1,v=(1<<a.distbits)-1;t:do{g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=m[b&p];e:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,0===y)A[o++]=65535&k;else{if(!(16&y)){if(0===(64&y)){k=m[(65535&k)+(b&(1<<y)-1)];continue e}if(32&y){a.mode=n;break t}t.msg=\"invalid literal/length code\",a.mode=i;break t}x=65535&k,y&=15,y&&(g<y&&(b+=E[r++]<<g,g+=8),x+=b&(1<<y)-1,b>>>=y,g-=y),g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=w[b&v];a:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,!(16&y)){if(0===(64&y)){k=w[(65535&k)+(b&(1<<y)-1)];continue a}t.msg=\"invalid distance code\",a.mode=i;break t}if(z=65535&k,y&=15,g<y&&(b+=E[r++]<<g,g+=8,g<y&&(b+=E[r++]<<g,g+=8)),z+=b&(1<<y)-1,z>d){t.msg=\"invalid distance too far back\",a.mode=i;break t}if(b>>>=y,g-=y,y=o-l,z>y){if(y=z-y,y>_&&a.sane){t.msg=\"invalid distance too far back\",a.mode=i;break t}if(B=0,S=c,0===u){if(B+=f-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}else if(u<y){if(B+=f+u-y,y-=u,y<x){x-=y;do A[o++]=c[B++];while(--y);if(B=0,u<x){y=u,x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}}else if(B+=u-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}for(;x>2;)A[o++]=S[B++],A[o++]=S[B++],A[o++]=S[B++],x-=3;x&&(A[o++]=S[B++],x>1&&(A[o++]=S[B++]))}else{B=o-z;do A[o++]=A[B++],A[o++]=A[B++],A[o++]=A[B++],x-=3;while(x>2);x&&(A[o++]=A[B++],x>1&&(A[o++]=A[B++]))}break}}break}}while(r<s&&o<h);x=g>>3,r-=x,g-=x<<3,b&=(1<<g)-1,t.next_in=r,t.next_out=o,t.avail_in=r<s?5+(s-r):5-(r-s),t.avail_out=o<h?257+(h-o):257-(o-h),a.hold=b,a.bits=g}},{}],11:[function(t,e,a){\"use strict\";function i(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function n(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new w.Buf16(320),this.work=new w.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function r(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg=\"\",e.wrap&&(t.adler=1&e.wrap),e.mode=T,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new w.Buf32(bt),e.distcode=e.distdyn=new w.Buf32(gt),e.sane=1,e.back=-1,Z):N}function s(t){var e;return t&&t.state?(e=t.state,e.wsize=0,e.whave=0,e.wnext=0,r(t)):N}function o(t,e){var a,i;return t&&t.state?(i=t.state,e<0?(a=0,e=-e):(a=(e>>4)+1,e<48&&(e&=15)),e&&(e<8||e>15)?N:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,s(t))):N}function l(t,e){var a,i;return t?(i=new n,t.state=i,i.window=null,a=o(t,e),a!==Z&&(t.state=null),a):N}function h(t){return l(t,wt)}function d(t){if(pt){var e;for(g=new w.Buf32(512),m=new w.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(y(z,t.lens,0,288,g,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;y(B,t.lens,0,32,m,0,t.work,{bits:5}),pt=!1}t.lencode=g,t.lenbits=9,t.distcode=m,t.distbits=5}function f(t,e,a,i){var n,r=t.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new w.Buf8(r.wsize)),i>=r.wsize?(w.arraySet(r.window,e,a-r.wsize,r.wsize,0),r.wnext=0,r.whave=r.wsize):(n=r.wsize-r.wnext,n>i&&(n=i),w.arraySet(r.window,e,a-i,n,r.wnext),i-=n,i?(w.arraySet(r.window,e,a-i,i,0),r.wnext=i,r.whave=r.wsize):(r.wnext+=n,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=n))),0}function _(t,e){var a,n,r,s,o,l,h,_,u,c,b,g,m,bt,gt,mt,wt,pt,vt,kt,yt,xt,zt,Bt,St=0,Et=new w.Buf8(4),At=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return N;a=t.state,a.mode===X&&(a.mode=W),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,c=l,b=h,xt=Z;t:for(;;)switch(a.mode){case T:if(0===a.wrap){a.mode=W;break}for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(2&a.wrap&&35615===_){a.check=0,Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0),_=0,u=0,a.mode=F;break}if(a.flags=0,a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&_)<<8)+(_>>8))%31){t.msg=\"incorrect header check\",a.mode=_t;break}if((15&_)!==U){t.msg=\"unknown compression method\",a.mode=_t;break}if(_>>>=4,u-=4,yt=(15&_)+8,0===a.wbits)a.wbits=yt;else if(yt>a.wbits){t.msg=\"invalid window size\",a.mode=_t;break}a.dmax=1<<yt,t.adler=a.check=1,a.mode=512&_?q:X,_=0,u=0;break;case F:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.flags=_,(255&a.flags)!==U){t.msg=\"unknown compression method\",a.mode=_t;break}if(57344&a.flags){t.msg=\"unknown header flags set\",a.mode=_t;break}a.head&&(a.head.text=_>>8&1),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=L;case L:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.time=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,Et[2]=_>>>16&255,Et[3]=_>>>24&255,a.check=v(a.check,Et,4,0)),_=0,u=0,a.mode=H;case H:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.xflags=255&_,a.head.os=_>>8),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=j;case j:if(1024&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length=_,a.head&&(a.head.extra_len=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0}else a.head&&(a.head.extra=null);a.mode=K;case K:if(1024&a.flags&&(g=a.length,g>l&&(g=l),g&&(a.head&&(yt=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Array(a.head.extra_len)),w.arraySet(a.head.extra,n,s,g,yt)),512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,a.length-=g),a.length))break t;a.length=0,a.mode=M;case M:if(2048&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.name+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=P;case P:if(4096&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.comment+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.comment=null);a.mode=Y;case Y:if(512&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(65535&a.check)){t.msg=\"header crc mismatch\",a.mode=_t;break}_=0,u=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=X;break;case q:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}t.adler=a.check=i(_),_=0,u=0,a.mode=G;case G:if(0===a.havedict)return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,C;t.adler=a.check=1,a.mode=X;case X:if(e===E||e===A)break t;case W:if(a.last){_>>>=7&u,u-=7&u,a.mode=ht;break}for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}switch(a.last=1&_,_>>>=1,u-=1,3&_){case 0:a.mode=J;break;case 1:if(d(a),a.mode=at,e===A){_>>>=2,u-=2;break t}break;case 2:a.mode=$;break;case 3:t.msg=\"invalid block type\",a.mode=_t}_>>>=2,u-=2;break;case J:for(_>>>=7&u,u-=7&u;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if((65535&_)!==(_>>>16^65535)){t.msg=\"invalid stored block lengths\",a.mode=_t;break}if(a.length=65535&_,_=0,u=0,a.mode=Q,e===A)break t;case Q:a.mode=V;case V:if(g=a.length){if(g>l&&(g=l),g>h&&(g=h),0===g)break t;w.arraySet(r,n,s,g,o),l-=g,s+=g,h-=g,o+=g,a.length-=g;break}a.mode=X;break;case $:\nfor(;u<14;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.nlen=(31&_)+257,_>>>=5,u-=5,a.ndist=(31&_)+1,_>>>=5,u-=5,a.ncode=(15&_)+4,_>>>=4,u-=4,a.nlen>286||a.ndist>30){t.msg=\"too many length or distance symbols\",a.mode=_t;break}a.have=0,a.mode=tt;case tt:for(;a.have<a.ncode;){for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.lens[At[a.have++]]=7&_,_>>>=3,u-=3}for(;a.have<19;)a.lens[At[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,zt={bits:a.lenbits},xt=y(x,a.lens,0,19,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg=\"invalid code lengths set\",a.mode=_t;break}a.have=0,a.mode=et;case et:for(;a.have<a.nlen+a.ndist;){for(;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(wt<16)_>>>=gt,u-=gt,a.lens[a.have++]=wt;else{if(16===wt){for(Bt=gt+2;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_>>>=gt,u-=gt,0===a.have){t.msg=\"invalid bit length repeat\",a.mode=_t;break}yt=a.lens[a.have-1],g=3+(3&_),_>>>=2,u-=2}else if(17===wt){for(Bt=gt+3;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=3+(7&_),_>>>=3,u-=3}else{for(Bt=gt+7;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=11+(127&_),_>>>=7,u-=7}if(a.have+g>a.nlen+a.ndist){t.msg=\"invalid bit length repeat\",a.mode=_t;break}for(;g--;)a.lens[a.have++]=yt}}if(a.mode===_t)break;if(0===a.lens[256]){t.msg=\"invalid code -- missing end-of-block\",a.mode=_t;break}if(a.lenbits=9,zt={bits:a.lenbits},xt=y(z,a.lens,0,a.nlen,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg=\"invalid literal/lengths set\",a.mode=_t;break}if(a.distbits=6,a.distcode=a.distdyn,zt={bits:a.distbits},xt=y(B,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,zt),a.distbits=zt.bits,xt){t.msg=\"invalid distances set\",a.mode=_t;break}if(a.mode=at,e===A)break t;case at:a.mode=it;case it:if(l>=6&&h>=258){t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,k(t,b),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,a.mode===X&&(a.back=-1);break}for(a.back=0;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(mt&&0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.lencode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,a.length=wt,0===mt){a.mode=lt;break}if(32&mt){a.back=-1,a.mode=X;break}if(64&mt){t.msg=\"invalid literal/length code\",a.mode=_t;break}a.extra=15&mt,a.mode=nt;case nt:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=rt;case rt:for(;St=a.distcode[_&(1<<a.distbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.distcode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,64&mt){t.msg=\"invalid distance code\",a.mode=_t;break}a.offset=wt,a.extra=15&mt,a.mode=st;case st:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.offset+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg=\"invalid distance too far back\",a.mode=_t;break}a.mode=ot;case ot:if(0===h)break t;if(g=b-h,a.offset>g){if(g=a.offset-g,g>a.whave&&a.sane){t.msg=\"invalid distance too far back\",a.mode=_t;break}g>a.wnext?(g-=a.wnext,m=a.wsize-g):m=a.wnext-g,g>a.length&&(g=a.length),bt=a.window}else bt=r,m=o-a.offset,g=a.length;g>h&&(g=h),h-=g,a.length-=g;do r[o++]=bt[m++];while(--g);0===a.length&&(a.mode=it);break;case lt:if(0===h)break t;r[o++]=a.length,h--,a.mode=it;break;case ht:if(a.wrap){for(;u<32;){if(0===l)break t;l--,_|=n[s++]<<u,u+=8}if(b-=h,t.total_out+=b,a.total+=b,b&&(t.adler=a.check=a.flags?v(a.check,r,b,o-b):p(a.check,r,b,o-b)),b=h,(a.flags?_:i(_))!==a.check){t.msg=\"incorrect data check\",a.mode=_t;break}_=0,u=0}a.mode=dt;case dt:if(a.wrap&&a.flags){for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(4294967295&a.total)){t.msg=\"incorrect length check\",a.mode=_t;break}_=0,u=0}a.mode=ft;case ft:xt=R;break t;case _t:xt=O;break t;case ut:return D;case ct:default:return N}return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,(a.wsize||b!==t.avail_out&&a.mode<_t&&(a.mode<ht||e!==S))&&f(t,t.output,t.next_out,b-t.avail_out)?(a.mode=ut,D):(c-=t.avail_in,b-=t.avail_out,t.total_in+=c,t.total_out+=b,a.total+=b,a.wrap&&b&&(t.adler=a.check=a.flags?v(a.check,r,b,t.next_out-b):p(a.check,r,b,t.next_out-b)),t.data_type=a.bits+(a.last?64:0)+(a.mode===X?128:0)+(a.mode===at||a.mode===Q?256:0),(0===c&&0===b||e===S)&&xt===Z&&(xt=I),xt)}function u(t){if(!t||!t.state)return N;var e=t.state;return e.window&&(e.window=null),t.state=null,Z}function c(t,e){var a;return t&&t.state?(a=t.state,0===(2&a.wrap)?N:(a.head=e,e.done=!1,Z)):N}function b(t,e){var a,i,n,r=e.length;return t&&t.state?(a=t.state,0!==a.wrap&&a.mode!==G?N:a.mode===G&&(i=1,i=p(i,e,r,0),i!==a.check)?O:(n=f(t,e,r,r))?(a.mode=ut,D):(a.havedict=1,Z)):N}var g,m,w=t(\"../utils/common\"),p=t(\"./adler32\"),v=t(\"./crc32\"),k=t(\"./inffast\"),y=t(\"./inftrees\"),x=0,z=1,B=2,S=4,E=5,A=6,Z=0,R=1,C=2,N=-2,O=-3,D=-4,I=-5,U=8,T=1,F=2,L=3,H=4,j=5,K=6,M=7,P=8,Y=9,q=10,G=11,X=12,W=13,J=14,Q=15,V=16,$=17,tt=18,et=19,at=20,it=21,nt=22,rt=23,st=24,ot=25,lt=26,ht=27,dt=28,ft=29,_t=30,ut=31,ct=32,bt=852,gt=592,mt=15,wt=mt,pt=!0;a.inflateReset=s,a.inflateReset2=o,a.inflateResetKeep=r,a.inflateInit=h,a.inflateInit2=l,a.inflate=_,a.inflateEnd=u,a.inflateGetHeader=c,a.inflateSetDictionary=b,a.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./inffast\":10,\"./inftrees\":12}],12:[function(t,e,a){\"use strict\";var i=t(\"../utils/common\"),n=15,r=852,s=592,o=0,l=1,h=2,d=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],f=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],_=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],u=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,a,c,b,g,m,w){var p,v,k,y,x,z,B,S,E,A=w.bits,Z=0,R=0,C=0,N=0,O=0,D=0,I=0,U=0,T=0,F=0,L=null,H=0,j=new i.Buf16(n+1),K=new i.Buf16(n+1),M=null,P=0;for(Z=0;Z<=n;Z++)j[Z]=0;for(R=0;R<c;R++)j[e[a+R]]++;for(O=A,N=n;N>=1&&0===j[N];N--);if(O>N&&(O=N),0===N)return b[g++]=20971520,b[g++]=20971520,w.bits=1,0;for(C=1;C<N&&0===j[C];C++);for(O<C&&(O=C),U=1,Z=1;Z<=n;Z++)if(U<<=1,U-=j[Z],U<0)return-1;if(U>0&&(t===o||1!==N))return-1;for(K[1]=0,Z=1;Z<n;Z++)K[Z+1]=K[Z]+j[Z];for(R=0;R<c;R++)0!==e[a+R]&&(m[K[e[a+R]]++]=R);if(t===o?(L=M=m,z=19):t===l?(L=d,H-=257,M=f,P-=257,z=256):(L=_,M=u,z=-1),F=0,R=0,Z=C,x=g,D=O,I=0,k=-1,T=1<<O,y=T-1,t===l&&T>r||t===h&&T>s)return 1;for(;;){B=Z-I,m[R]<z?(S=0,E=m[R]):m[R]>z?(S=M[P+m[R]],E=L[H+m[R]]):(S=96,E=0),p=1<<Z-I,v=1<<D,C=v;do v-=p,b[x+(F>>I)+v]=B<<24|S<<16|E|0;while(0!==v);for(p=1<<Z-1;F&p;)p>>=1;if(0!==p?(F&=p-1,F+=p):F=0,R++,0===--j[Z]){if(Z===N)break;Z=e[a+m[R]]}if(Z>O&&(F&y)!==k){for(0===I&&(I=O),x+=C,D=Z-I,U=1<<D;D+I<N&&(U-=j[D+I],!(U<=0));)D++,U<<=1;if(T+=1<<D,t===l&&T>r||t===h&&T>s)return 1;k=F&y,b[k]=O<<24|D<<16|x-g|0}}return 0!==F&&(b[x+F]=Z-I<<24|64<<16|0),w.bits=O,0}},{\"../utils/common\":3}],13:[function(t,e,a){\"use strict\";e.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],14:[function(t,e,a){\"use strict\";function i(t){for(var e=t.length;--e>=0;)t[e]=0}function n(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function r(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function s(t){return t<256?lt[t]:lt[256+(t>>>7)]}function o(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function l(t,e,a){t.bi_valid>W-a?(t.bi_buf|=e<<t.bi_valid&65535,o(t,t.bi_buf),t.bi_buf=e>>W-t.bi_valid,t.bi_valid+=a-W):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)}function h(t,e,a){l(t,a[2*e],a[2*e+1])}function d(t,e){var a=0;do a|=1&t,t>>>=1,a<<=1;while(--e>0);return a>>>1}function f(t){16===t.bi_valid?(o(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}function _(t,e){var a,i,n,r,s,o,l=e.dyn_tree,h=e.max_code,d=e.stat_desc.static_tree,f=e.stat_desc.has_stree,_=e.stat_desc.extra_bits,u=e.stat_desc.extra_base,c=e.stat_desc.max_length,b=0;for(r=0;r<=X;r++)t.bl_count[r]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<G;a++)i=t.heap[a],r=l[2*l[2*i+1]+1]+1,r>c&&(r=c,b++),l[2*i+1]=r,i>h||(t.bl_count[r]++,s=0,i>=u&&(s=_[i-u]),o=l[2*i],t.opt_len+=o*(r+s),f&&(t.static_len+=o*(d[2*i+1]+s)));if(0!==b){do{for(r=c-1;0===t.bl_count[r];)r--;t.bl_count[r]--,t.bl_count[r+1]+=2,t.bl_count[c]--,b-=2}while(b>0);for(r=c;0!==r;r--)for(i=t.bl_count[r];0!==i;)n=t.heap[--a],n>h||(l[2*n+1]!==r&&(t.opt_len+=(r-l[2*n+1])*l[2*n],l[2*n+1]=r),i--)}}function u(t,e,a){var i,n,r=new Array(X+1),s=0;for(i=1;i<=X;i++)r[i]=s=s+a[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=d(r[o]++,o))}}function c(){var t,e,a,i,r,s=new Array(X+1);for(a=0,i=0;i<K-1;i++)for(dt[i]=a,t=0;t<1<<et[i];t++)ht[a++]=i;for(ht[a-1]=i,r=0,i=0;i<16;i++)for(ft[i]=r,t=0;t<1<<at[i];t++)lt[r++]=i;for(r>>=7;i<Y;i++)for(ft[i]=r<<7,t=0;t<1<<at[i]-7;t++)lt[256+r++]=i;for(e=0;e<=X;e++)s[e]=0;for(t=0;t<=143;)st[2*t+1]=8,t++,s[8]++;for(;t<=255;)st[2*t+1]=9,t++,s[9]++;for(;t<=279;)st[2*t+1]=7,t++,s[7]++;for(;t<=287;)st[2*t+1]=8,t++,s[8]++;for(u(st,P+1,s),t=0;t<Y;t++)ot[2*t+1]=5,ot[2*t]=d(t,5);_t=new n(st,et,M+1,P,X),ut=new n(ot,at,0,Y,X),ct=new n(new Array(0),it,0,q,J)}function b(t){var e;for(e=0;e<P;e++)t.dyn_ltree[2*e]=0;for(e=0;e<Y;e++)t.dyn_dtree[2*e]=0;for(e=0;e<q;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*Q]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function g(t){t.bi_valid>8?o(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function m(t,e,a,i){g(t),i&&(o(t,a),o(t,~a)),N.arraySet(t.pending_buf,t.window,e,a,t.pending),t.pending+=a}function w(t,e,a,i){var n=2*e,r=2*a;return t[n]<t[r]||t[n]===t[r]&&i[e]<=i[a]}function p(t,e,a){for(var i=t.heap[a],n=a<<1;n<=t.heap_len&&(n<t.heap_len&&w(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!w(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i}function v(t,e,a){var i,n,r,o,d=0;if(0!==t.last_lit)do i=t.pending_buf[t.d_buf+2*d]<<8|t.pending_buf[t.d_buf+2*d+1],n=t.pending_buf[t.l_buf+d],d++,0===i?h(t,n,e):(r=ht[n],h(t,r+M+1,e),o=et[r],0!==o&&(n-=dt[r],l(t,n,o)),i--,r=s(i),h(t,r,a),o=at[r],0!==o&&(i-=ft[r],l(t,i,o)));while(d<t.last_lit);h(t,Q,e)}function k(t,e){var a,i,n,r=e.dyn_tree,s=e.stat_desc.static_tree,o=e.stat_desc.has_stree,l=e.stat_desc.elems,h=-1;for(t.heap_len=0,t.heap_max=G,a=0;a<l;a++)0!==r[2*a]?(t.heap[++t.heap_len]=h=a,t.depth[a]=0):r[2*a+1]=0;for(;t.heap_len<2;)n=t.heap[++t.heap_len]=h<2?++h:0,r[2*n]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=s[2*n+1]);for(e.max_code=h,a=t.heap_len>>1;a>=1;a--)p(t,r,a);n=l;do a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],p(t,r,1),i=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=i,r[2*n]=r[2*a]+r[2*i],t.depth[n]=(t.depth[a]>=t.depth[i]?t.depth[a]:t.depth[i])+1,r[2*a+1]=r[2*i+1]=n,t.heap[1]=n++,p(t,r,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],_(t,e),u(r,h,t.bl_count)}function y(t,e,a){var i,n,r=-1,s=e[1],o=0,l=7,h=4;for(0===s&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=s,s=e[2*(i+1)+1],++o<l&&n===s||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==r&&t.bl_tree[2*n]++,t.bl_tree[2*V]++):o<=10?t.bl_tree[2*$]++:t.bl_tree[2*tt]++,o=0,r=n,0===s?(l=138,h=3):n===s?(l=6,h=3):(l=7,h=4))}function x(t,e,a){var i,n,r=-1,s=e[1],o=0,d=7,f=4;for(0===s&&(d=138,f=3),i=0;i<=a;i++)if(n=s,s=e[2*(i+1)+1],!(++o<d&&n===s)){if(o<f){do h(t,n,t.bl_tree);while(0!==--o)}else 0!==n?(n!==r&&(h(t,n,t.bl_tree),o--),h(t,V,t.bl_tree),l(t,o-3,2)):o<=10?(h(t,$,t.bl_tree),l(t,o-3,3)):(h(t,tt,t.bl_tree),l(t,o-11,7));o=0,r=n,0===s?(d=138,f=3):n===s?(d=6,f=3):(d=7,f=4)}}function z(t){var e;for(y(t,t.dyn_ltree,t.l_desc.max_code),y(t,t.dyn_dtree,t.d_desc.max_code),k(t,t.bl_desc),e=q-1;e>=3&&0===t.bl_tree[2*nt[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}function B(t,e,a,i){var n;for(l(t,e-257,5),l(t,a-1,5),l(t,i-4,4),n=0;n<i;n++)l(t,t.bl_tree[2*nt[n]+1],3);x(t,t.dyn_ltree,e-1),x(t,t.dyn_dtree,a-1)}function S(t){var e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return D;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return I;for(e=32;e<M;e++)if(0!==t.dyn_ltree[2*e])return I;return D}function E(t){bt||(c(),bt=!0),t.l_desc=new r(t.dyn_ltree,_t),t.d_desc=new r(t.dyn_dtree,ut),t.bl_desc=new r(t.bl_tree,ct),t.bi_buf=0,t.bi_valid=0,b(t)}function A(t,e,a,i){l(t,(T<<1)+(i?1:0),3),m(t,e,a,!0)}function Z(t){l(t,F<<1,3),h(t,Q,st),f(t)}function R(t,e,a,i){var n,r,s=0;t.level>0?(t.strm.data_type===U&&(t.strm.data_type=S(t)),k(t,t.l_desc),k(t,t.d_desc),s=z(t),n=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=n&&(n=r)):n=r=a+5,a+4<=n&&e!==-1?A(t,e,a,i):t.strategy===O||r===n?(l(t,(F<<1)+(i?1:0),3),v(t,st,ot)):(l(t,(L<<1)+(i?1:0),3),B(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),v(t,t.dyn_ltree,t.dyn_dtree)),b(t),i&&g(t)}function C(t,e,a){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&a,t.last_lit++,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(ht[a]+M+1)]++,t.dyn_dtree[2*s(e)]++),t.last_lit===t.lit_bufsize-1}var N=t(\"../utils/common\"),O=4,D=0,I=1,U=2,T=0,F=1,L=2,H=3,j=258,K=29,M=256,P=M+1+K,Y=30,q=19,G=2*P+1,X=15,W=16,J=7,Q=256,V=16,$=17,tt=18,et=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],at=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],it=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],nt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],rt=512,st=new Array(2*(P+2));i(st);var ot=new Array(2*Y);i(ot);var lt=new Array(rt);i(lt);var ht=new Array(j-H+1);i(ht);var dt=new Array(K);i(dt);var ft=new Array(Y);i(ft);var _t,ut,ct,bt=!1;a._tr_init=E,a._tr_stored_block=A,a._tr_flush_block=R,a._tr_tally=C,a._tr_align=Z},{\"../utils/common\":3}],15:[function(t,e,a){\"use strict\";function i(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}e.exports=i},{}],\"/\":[function(t,e,a){\"use strict\";var i=t(\"./lib/utils/common\").assign,n=t(\"./lib/deflate\"),r=t(\"./lib/inflate\"),s=t(\"./lib/zlib/constants\"),o={};i(o,n,r,s),e.exports=o},{\"./lib/deflate\":1,\"./lib/inflate\":2,\"./lib/utils/common\":3,\"./lib/zlib/constants\":6}]},{},[])(\"/\")});\n";
bitmap_support_ZipSupport.haxeZipCompressJsSupportOnce = false;
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
Main.main();
})({});

//# sourceMappingURL=main.js.map